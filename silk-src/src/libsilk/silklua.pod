=pod

=head1 NAME

B<silklua> - Lua interpreter with a SiLK environment

=head1 SYNOPSIS

B<silklua> [ I<OPTIONS> ] [ I<SCRIPT> [ I<ARGS> ] ]

=head1 DESCRIPTION

B<silklua> is a stand-alone Lua interpreter, similar to B<lua(1)>,
that also includes SiLK support.

B<silklua> loads and executes Lua programs or it can be run
interactively.  Quoting from the B<lua> man page:

=over 4

The given I<OPTIONS> are handled in order and then the Lua program in
file I<SCRIPT> is loaded and executed.  The given I<ARGS> are
available to I<SCRIPT> as strings in a global table named B<arg>.  If
no options or arguments are given, then B<-v> B<-i> is assumed when
the standard input is a terminal; otherwise, B<-> is assumed.

In interactive mode, B<lua> prompts the user, reads lines from the
standard input, and executes them as they are read.  If the line
contains an expression or list of expressions, then the line is
evaluated and the results are printed.  If a line does not contain a
complete statement, then a secondary prompt is displayed and lines
are read until a complete statement is formed or a syntax error is
found.

=back

Nearly all of the remainder of this document describes the SiLK Lua
environment.

=head1 OBJECT TYPES

The SiLK Lua environment defines the following object types:

=over 4

=item L<bitmap|/Bitmap>

Represents an array of true/false values.  May be created by
L<silk.B<bitmap()>|/"silk.B<bitmap(>I<size>B<)>">.

=item L<datetime|/Datetime>

Represents a point in time to millisecond precision.  May be created
directly by L<silk.B<datetime()>|/"silk.B<datetime(>I<string>B<)>">.

=item L<field|/Field>

Represents a member of a L<schema|/Schema>.  A field also represents an
IPFIX Information Element (IE).  These are created as a byproduct of
creating a schema and may not be created directly.

=item L<fixlist|/Record List>

Represents an IPFIX structured data [RFC6313]; that is, a basicList, a
subTemplateList, or a subTemplateMultiList.  Getting a L<field|/Field>
from an IPFIX record (a L<fixrec|/Fixrec>) whose value is a structured
data returns a fixlist object.  May also be created directly by
L<silk.B<fixlist()>|/"silk.B<fixlist(>I<list_type>[, I<schema> | I<elem>, I<elem>...]B<)>">.

=item L<fixrec|/Fixrec>

Represents an IPFIX record or an IPFIX representation of a SiLK Flow
record.  Every record is described by a L<schema|/Schema>.  May be
created directly by
L<silk.B<fixrec()>|/"silk.B<fixrec(>I<schema>[, I<table>]B<)>">.

=item L<ipaddr|/IP Address>

Represents an IP address.  May be created directly by
L<silk.B<ipaddr()>|/"silk.B<ipaddr(>I<address>B<)>">,
L<silk.B<ipv4addr()>|/"silk.B<ipv4addr(>I<addr>B<)>">,
L<silk.B<ipv6addr()>|/"silk.B<ipv6addr(>I<addr>B<)>">,
L<silk.B<ipaddr_from_bytes()>|/"silk.B<ipaddr_from_bytes(>I<bytes>B<)>">,
L<silk.B<ipaddr_ipv4_from_bytes()>|/"silk.B<ipaddr_ipv4_from_bytes(>I<bytes>B<)>">,
or
L<silk.B<ipaddr_ipv6_from_bytes()>|/"silk.B<ipaddr_ipv6_from_bytes(>I<bytes>B<)>">.

=item L<ipset|/IPset>

Represents a SiLK IPset.  May be created by
L<silk.B<ipset()>|/"silk.B<ipset(>[I<element_array>]B<)>"> or
L<silk.B<ipset_load()>|/"silk.B<ipset_load(>I<filename>B<)>">.

=item L<ipwildcard|/IP Wildcard>

Represents a CIDR block or a SiLK IP wildcard address set.  May be
created by
L<silk.B<ipwildcard()>|/"silk.B<ipwildcard(>I<wildcard>B<)>">.

=item L<pmap|/Prefix Map>

Represents a SiLK prefix map.  A prefix map typically maps ranges of
IP addresses to strings, though a prefix map may also be used to map a
ranges or protocol/port pairs to strings.  May be created by
L<silk.B<pmap()>|/"silk.B<pmap(>I<filename>B<)>"> or
L<silk.B<pmap_load()>|/"silk.B<pmap_load(>I<filename>B<)>">.

=item L<rwrec|/RWRec>

Represents a SiLK Flow record.  An RWRec has a fixed set of elements
in a fixed layout, and it may also have a Lua table containing
additional key-value pairs that augment the record.  This table is
referred to as I<sidecar> data.  The sidecar data is described by a
L<sidecar|/Sidecar> object.  May be
created directly by
L<silk.B<rwrec()>|/"silk.B<rwrec(>[I<table>]B<)>">.

=item L<schema|/Schema>

Represents a sequence of L<field|/Field>s that describe a
L<fixrec|/Fixrec>.  A schema may also be thought of as a
representation of an IPFIX template.  May be created by
L<silk.B<schema()>|/"silk.B<schema(>[I<elem>[, ...]]B<)>">.

=item L<sidecar|/Sidecar>

Represents a description of a table of additional (I<sidecar>)
elements that may be added to an L<rwrec|/RWRec>.  A sidecar contains
L<sidecar_elem|/Sidecar Element>s.  A sidecar is created by
L<silk.B<sidecar()>|/"silk.B<sidecar(>[I<table>]B<)>">.

=item L<sidecar_elem|/Sidecar Element>

Represents an individual element of a L<sidecar|/Sidecar>.  A sidecar
element is created by Lua when a sidecar is created.

=item L<stream|/Stream>

Represents an input or output stream containing IPFIX or SiLK records.
To create and open a stream open for reading (input), use
L<silk.B<stream_open_reader(>I<filename>, I<type>B<)>|/"silk.B<stream_open_reader(>I<filename>, I<type>B<)>">.
To create and open a stream open for writing (output), use
L<silk.B<stream_open_writer(>I<filename>, I<type>B<)>|/"silk.B<stream_open_writer(>I<filename>, I<type>B<)>">.

=back

=head1 FUNCTIONS

The SiLK Lua environment defines the following functions.  The
functions are grouped by the type of object they operate on.

=head2 General Functions

These functions operate on a any Lua object.

=over 4

=item silk.B<is_bitmap(>I<obj>B<)>

Return C<true> if I<obj> is a L<bitmap|/Bitmap> object, C<false>
otherwise.

=item silk.B<is_datetime(>I<obj>B<)>

Return C<true> if I<obj> is a L<datetime|/Datetime> object, C<false>
otherwise.

=item silk.B<is_field(>I<obj>B<)>

Return C<true> if I<obj> is a L<field|/Field> object, C<false>
otherwise.

=item silk.B<is_fixlist(>I<obj>B<)>

Return C<true> if I<obj> is a L<fixlist|/Record List> object, C<false>
otherwise.

=item silk.B<is_fixrec(>I<obj>B<)>

Return C<true> if I<obj> is a L<fixrec|/Fixrec> object, C<false>
otherwise.

=item silk.B<is_ipaddr(>I<obj>B<)>

Return C<true> if I<obj> is an L<ipaddr|/IP Address> object, C<false>
otherwise.

=item silk.B<is_ipset(>I<obj>B<)>

Return C<true> if I<obj> is an L<ipset|/IPset> object, C<false>
otherwise.

=item silk.B<is_ipwildcard(>I<obj>B<)>

Return C<true> if I<obj> is an L<ipwildcard|/IP Wildcard> object,
C<false> otherwise.

=item silk.B<is_pmap(>I<obj>B<)>

Return C<true> if I<obj> is a L<pmap|/Prefix Map> object, C<false>
otherwise.

=item silk.B<is_rwrec(>I<obj>B<)>

Return C<true> if I<obj> is an L<rwrec|/RWRec> object, C<false>
otherwise.

=item silk.B<is_schema(>I<obj>B<)>

Return C<true> if I<obj> is a L<schema|/Schema> object, C<false>
otherwise.

=item silk.B<is_sidecar(>I<obj>B<)>

Return C<true> if I<obj> is a L<sidecar|/Sidecar> object, C<false>
otherwise.

=item silk.B<is_sidecar_elem(>B<)>

Return C<true> if I<obj> is a L<sidecar_elem|/Sidecar Element> object,
C<false> otherwise.

=item silk.B<is_stream(>I<obj>B<)>

Return C<true> if I<obj> is a L<stream|/Stream> object, C<false>
otherwise.

=item silk.B<to_string(>I<obj>B<)>

Return the result of C<silk.I<type>_to_string(I<obj>)> where I<type>
is determined by calling C<silk.type(I<obj>)>.  If the
B<I<type>_to_string()> function does not exist, return the result of
C<tostring(I<obj>)>; that is, the the standard Lua B<tostring()>
function.

=item silk.B<type(>I<obj>B<)>

Return a string giving the type of I<obj>, akin to the Lua function
B<type(I<obj>)>.  The difference is that silk.type() returns the name
of one of the SiLK objects referenced in L</OBJECT TYPES> rather than
returning C<userdata>.

=back

=head2 General SiLK Functions

The following general functions exist:

=over 4

=item silk.B<init_country_codes(>[I<filename>]B<)>

Initialize the country code database.  I<filename> should be the
path to a country code prefix map, as created by
B<rwgeoip2ccmap(1)>.  If I<filename> is not supplied or B<nil>,
SiLK looks first for the file specified by F<$SILK_COUNTRY_CODES>,
and then for a file named F<country_codes.pmap> in
F<$SILK_PATH/share/silk>, F<$SILK_PATH/share>,
F<@prefix@/share/silk>, and F<@prefix@/share>.  (The latter two
assume that SiLK was installed in F<@prefix@>.)  The function
raises an error if loading the country code prefix map fails.

=item silk.B<file_format_from_id(>I<id>B<)>

Return the file format associated with the numeric ID I<id>.  Raise
an error if I<id> is not a valid file format ID.

=item silk.B<file_format_id(>I<name>B<)>

Return the numeric ID associated with the file format I<name>.
Raise an error if I<name> is not a valid file format.

=back

=head2 Attributes (silkTCPState IE)

I<Attributes> refers to the B<attributes> field in SiLK 3.  These
values are put into the silkTCPState information element (elementId 32
in the CERT enterpriseId 6871) when a SiLK Flow record is converted to
IPFIX.

There is not a dedicated object type to store flow attributes, and
B<silklua> uses the number type in Lua to hold flow attributes.

The following functions help to convert between the letters used in
SiLK 3 and the integer value stored in the silkTCPState IE.

=over 4

=item silk.B<attributes_matches(>I<integer>, I<string>B<)>

Treat I<integer> as a flow attributes value, such as that produced
by B<attributes_parse()>.

Parse I<string> as a pair of flow attributes values separated by a
slash (C</>), where the values before and after the slash are
parsed using B<attributes_parse()>.

Treat the flow attributes value that appear after the slash as a
mask, and use it to mask the flow attributes in I<integer>.

Treat the flow attributes value that appear before the slash as a
check, and verify that the masked attributes value matches it.  If
the values match, return B<true>; otherwise, return B<false>.

When no slash is present in I<string>, parse it using
B<attributes_parse()> and treat it as both the mask and the bits to
check.

=item silk.B<attributes_parse(>I<string>B<)>

Parse I<string> as a set of flow attributes and return an unsigned
integer representing those attributes.  Any whitespace in I<string>
is ignored.  I<string> may contain the following characters, which
map to the specified value.

=over 4

=item C, c

0x40.  Flow is a continuation of a previous flow that was killed
prematurely due to a timeout by the collector.

=item T, t

0x20.  Flow ends prematurely due to a timeout by the collector.

=item S, s

0x10.  Flow has packets all of the same size.

=item F, f

0x08.  Flow received packets following the FIN packet that were not
ACK or RST packets.

=back

=item silk.B<attributes_to_string(>I<integer>[, I<format>]B<)>

Assume I<integer> represents a flow attributes value and return a
human-readable version of those attributes.

Possible values for I<format> are:

=over 4

=item padded

Format the flow attributes with a space representing any unset flag.

=item compact

Format the flow attributes in as few characters as possible.  When
I<integer> is 0, the empty string is returned.

=back

When no I<format> value is specified, the default is I<compact>.

=back

=head2 Bitmap

A B<bitmap> object represents an array of true/false values.

The following function creates a bitmap object:

=over 4

=item silk.B<bitmap(>I<size>B<)>

Create and return a new bitmap capable of holding B<true>/B<false>
values where the allowable bitmap indexes range from 0 to 1 less
than I<size>.  All bits in the new bitmap are set to B<false>.

=back

The following operator-type functions are defined for bitmap objects:

=over 4

=item B<#>I<bitmap>

An alias for
L<silk.B<bitmap_get_size()>|/"silk.B<bitmap_get_size(>I<bitmap>B<)>">.

=item I<bitmap>B<[> I<n> B<]>

An alias for
L<silk.B<bitmap_get_bit()>|/"silk.B<bitmap_get_bit(>I<bitmap>, I<n>B<)>">.

=back

The following functions are defined for bitmap objects:

=over 4

=item silk.B<bitmap_clear_all(>I<bitmap>B<)>

Set to B<false> (set to 0; turn off) all bits in I<bitmap>.

=item silk.B<bitmap_clear_bit(>I<bitmap>B<)>

Set to B<false> (set to 0; turn off) bit I<n> in I<bitmap>.

Raise an error if I<n> is equal to or greater than the size of
I<bitmap>.

=item silk.B<bitmap_clear_range(>I<bitmap>, I<start_pos>, I<end_pos>B<)>

Set to B<false> (set to 0; turn off) all bits in I<bitmap> from
I<start_pos> to I<end_pos> inclusive.

Raise an error if I<end_pos> is equal to or greater than the size
of I<bitmap> or if I<start_pos> is greater than I<end_pos>.

=item silk.B<bitmap_compliment_update(>I<bitmap>B<)>

Flip all bits in I<bitmap> so that bits that were B<false> are now
B<true> and bits that were B<true> are now B<false>.

=item silk.B<bitmap_copy(>I<bitmap>B<)>

Create and return a copy of I<bitmap>.

=item silk.B<bitmap_count_consecutive(>I<bitmap>, I<start_pos>, I<state>B<)>

Starting from I<start_pos> and increasing the index, count and
return the number of bits in I<bitmap> whose state is I<state>.
When I<state> is a number, 0 is false and any other value is true;
otherwise, I<state> is interpreted as a Lua boolean value.

Raise an error if I<start_pos> is equal to or greater than the size of
I<bitmap>.

=item silk.B<bitmap_count_range(>I<bitmap>, I<start_pos>, I<end_pos>B<)>

Return the number of bits that are B<true> (set to 1; turned on) in
I<bitmap> between I<start_pos> to I<end_pos> inclusive.

Raise an error if I<end_pos> is equal to or greater than the size
of I<bitmap> or if I<start_pos> is greater than I<end_pos>.

=item silk.B<bitmap_get_bit(>I<bitmap>, I<n>B<)>

Return the state of bit I<n> in I<bitmap>; that is, return B<true>
if bit I<n> in I<bitmap> is 1 or return B<false> if it is 0.

Raise an error if I<n> is equal to or greater than the size of
I<bitmap>.

=item silk.B<bitmap_get_count(>I<bitmap>B<)>

Return the number of bits that are B<true> (set to 1; turned on) in
I<bitmap>.

=item silk.B<bitmap_get_size(>I<bitmap>B<)>

Return the size that was specified when I<bitmap> was created.

=item silk.B<bitmap_intersect_update(>I<bitmap>, I<bitmap2>B<)>

Compute the intersection of I<bitmap> and I<bitmap2>, putting the
result in B<bitmap>.  In effect, this sets to B<false> all bits in
I<bitmap> that are B<false> in I<bitmap2>.  (Bits in I<bitmap> that
were previously B<false> are unchanged.)

Raise an error if I<bitmap> and I<bitmap2> are of different sizes.

=item silk.B<bitmap_iter(>I<bitmap>B<)>

Return an iterator that returns the positions of all the set bits
in I<bitmap>.

=item silk.B<bitmap_set_all(>I<bitmap>B<)>

Set to B<true> (set to 1; turn on) all bits in I<bitmap>.

=item silk.B<bitmap_set_bit(>I<bitmap>B<)>

Set to B<true> (set to 1; turn on) bit I<n> in I<bitmap>.

Raise an error if I<n> is equal to or greater than the size of
I<bitmap>.

=item silk.B<bitmap_set_range(>I<bitmap>, I<start_pos>, I<end_pos>B<)>

Set to B<true> (set to 1; turn on) all bits in I<bitmap> from
I<start_pos> to I<end_pos> inclusive.

Raise an error if I<end_pos> is equal to or greater than the size
of I<bitmap> or if I<start_pos> is greater than I<end_pos>.

=item silk.B<bitmap_to_string(>I<bitmap>B<)>

Return a unique string designating I<bitmap>.

=item silk.B<bitmap_union_update(>I<bitmap>B<)>

Compute the union of I<bitmap> and I<bitmap2>, putting the result
in B<bitmap>.  In effect, this sets to B<true> all bits in I<bitmap>
that are B<true> in I<bitmap2>.  (Bits in I<bitmap> that were
previously B<true> are unchanged.)

Raise an error if I<bitmap> and I<bitmap2> are of different sizes.

=back

=head2 Datetime

A B<datetime> object represents a point in time to millisecond
precision.

The following functions create a datetime object:

=over 4

=item silk.B<datetime(>I<string>B<)>

Parse I<string> as a date-time and return an datetime object
representing the number of milliseconds since the UNIX epoch.
I<string> must represent a time to at least day precision.

The format for I<string> is that accepted by B<rwfilter(1)>.

=item silk.B<datetime(>I<number>B<)>

Create a datetime object from a number.  The number represents the
number of milliseconds since the UNIX epoch time.

=back

The following functions are defined for datetime objects:

=over 4

=item silk.B<datetime_add_duration(>I<datetime>, I<number>B<)>

Return a new datetime that is the sum of I<datetime> and I<number>
milliseconds.  I<number> may be negative.  An error is thrown
if the operation would cause an overflow or an underflow.

=item silk.B<datetime_difference(>I<end>, I<start>B<)>

Return the difference of the datetime I<end> minus the datetime
I<start> as a number of milliseconds.

=item silk.B<datetime_parse_range(>I<string>B<)>

Parse I<string> as a pair of date-time strings separated by a
single hyphen C<-> and return a pair of datetimes representing the
start of the range and the end of the range.  Both dates in
I<string> must represent times to at least day precision.

When the end time is not specified to millisecond precision, any
unspecified values are set to the maximum possible value.

The format for I<string> is that accepted by B<rwfilter(1)>.

=item silk.B<datetime_to_number(>I<datetime>B<)>

Return I<datetime> as a number of milliseconds since the UNIX epoch
datetime.

=item silk.B<datetime_to_string(>I<datetime>[, I<format>[, I<format>...]]B<)>

Return a human-readable version of the given datetime.

Possible values for I<format> are zero or more of the following:

=over 4

=item y/m/d

Format the timestamp as I<YYYY>/I<MM>/I<DD>TI<hh>:I<mm>:I<ss>.I<sss>.

=item iso

Format the timestamp as I<YYYY>-I<MM>-I<DD> I<hh>:I<mm>:I<ss>.I<sss>.

=item m/d/y

Format the timestamp as I<MM>/I<DD>/I<YYYY> I<hh>:I<mm>:I<ss>.I<sss>.

=item epoch

Format the timestamp as the number of seconds since 00:00:00 UTC on
1970-01-01.

=back

When a timezone is specified, it is used regardless of the default
timezone support compiled into SiLK.  The timezone is one of:

=over 4

=item utc

Use Coordinated Universal Time to print timestamps.

=item local

Use the TZ environment variable or the local timezone.

=back

One modifier is available:

=over 4

=item no-msec

Truncate the milliseconds value on the timestamp.

=back

When no I<format> values are specified, the default is to print
milliseconds, use the the C<y/m/d> format, and use the default
timezone that was specified when SiLK was compiled.

=back

=head2 Field

A B<field> object represents a member of a L<schema|/Schema>.  A field
also represents an IPFIX Information Element (IE).  Use
L<silk.B<schema_get_field()>|/"silk.B<schema_get_field(>I<schema>, {I<field> | I<position> | I<name> | I<table>}B<)>">
to get a field object from a schema.  A field may be used as an index
to a L<fixrec|/Fixrec> object.

The following operator-type function is defined for field objects:

=over 4

=item I<field>B<[> I<attribute> B<]>

Return the specified attribute of I<field>.  As always in Lua,
I<field>.I<attribute> works as well.  An alias for
L<silk.B<field_get_attribute()>|/"silk.B<field_get_attribute(>I<field>, I<attribute>B<)>">.

=back

The following functions are defined for field objects:

=over 4

=item B<pairs(>I<field>B<)>

Return an iterator designed for the Lua B<for> statement that
iterates over the (string, value) pairs of I<field>.  The
string represents an attribute of I<field>; the list of
attributes is documented by the
L<silk.B<field_get_attribute()>|/"silk.B<field_get_attribute(>I<field>, I<attribute>B<)>">
function.  The iterator skips attributes whose value is B<nil>.
May be used as
B<for I<attr_name>, I<value> in pairs(I<field>) do...end>

=item silk.B<field_get_attribute(>I<field>, I<attribute>B<)>

Return the specified attribute of I<field>.  The list of valid
attributes are:

=over 4

=item name

The name, a string

=item elementId

The integer identifier

=item enterpriseId

The Private Enterprise Number (PEN), an integer or B<nil> if the
field is from the standard information model

=item length

The length in octets, an integer or the string C<varlen> to
indicate a variable-length element

=item dataType

A string specifying the data type (IPFIX Information Element Data
Types values [RFC5610]).  One of C<octetArray>, C<unsigned8>,
C<unsigned16>, C<unsigned32>, C<unsigned64>, C<signed8>,
C<signed16>, C<signed32>, C<signed64>, C<float32>, C<float64>,
C<boolean>, C<macAddress>, C<string>, C<dateTimeSeconds>,
C<dateTimeMilliseconds>, C<dateTimeMicroseconds>,
C<dateTimeNanoseconds>, C<ipv4Address>, C<ipv6Address>,
C<basicList>, C<subTemplateList>, C<subTemplateMultiList>

=item dataTypeSemantics

A string specifying the data type semantics (IPFIX Information
Element Semantics values [RFC5610]).  One of C<default>,
C<quantity>, C<totalCounter>, C<deltaCounter>, C<identifier>,
C<flags>, C<list>

=item units

A string specifying the units (IPFIX Information Element Units
values [RFC5610]).  One of C<none>, C<bits>, C<octets>, C<packets>,
C<flows>, C<seconds>, C<milliseconds>, C<microseconds>,
C<nanoseconds>, C<fourOctetWords> (RFC5610's C<4-octet words>),
C<messages>, C<hops>, C<entries>, C<frames>

=item rangemin

The minimum legal value for an integer field or B<nil> if none

=item rangemax

The maximum legal value for an integer field or B<nil> if none

=item description

The description, a string or B<nil> if none

=item schema

The L<schema|/Schema> that owns this field.

=back

=item silk.B<field_to_string(>I<field>B<)>

Return the name attribute of I<field>.

=back

=head2 Record List

A B<fixlist> object represents an IPFIX structured data as defined in
RFC6313 (L<http://tools.ietf.org/html/rfc6313>).  A fixlist object is
returned by
L<silk.B<fixrec_get_value()>|/"silk.B<fixrec_get_value(>I<fixrec>, {I<field> | I<position> | I<name> | I<table>}[, I<notfound>]B<)>">
when a L<fixrec|/Fixrec> contains a structured data.  Use
silk.B<fixlist_iter()> to visit the elements in the list.  The
elements are represented as record objects.

The following function creates a fixlist object:

=over 4

=item silk.B<fixlist(>I<list_type>[, I<schema> | I<elem>, I<elem>...]B<)>

Create a fixlist (a fixrec list).  The I<list_type> argument is a
string specifying the type of list to create, and must be one of

=over 4

=item subTemplateMultiList

Create a list where the elements in the list may have different
schemas.  No additional arguments are permitted.

=item subTemplateList

Create a list where all elements in the list use the same schema.  One
or more arguments are required.

=item basicList

Create a list where all elements are the same type of information
element (IE).  One additional argument is required.

=back

When creating a subTemplateList, the schema to be used by the elements
in the list must be specified by providing either a single
L<schema|/Schema> argument or the elements needed to create a new
schema.

When creating a basicList, the IE of the elements in the list must be
specified by providing either a single I<elem> argument or a schema
argument that contains a single IE.

The form of each I<elem> argument is the same as that used by
L<silk.B<schema()>|/"silk.B<schema(>[I<elem>[, ...]]B<)>">.

=back

The following operator-type functions are defined for fixlist objects:

=over 4

=item B<#>I<fixlist>

Return the number of elements in I<fixlist>.  An alias for
B<fixlist_count_elements()>.

=item I<fixlist>B<[> I<position> B<]>

Return the fixrec in the fixrec list I<fixlist> at index
I<position>.  An alias for
L<B<fixlist_get_element()>|/"silk.B<fixlist_get_element(>I<fixlist>, I<position>B<)>">.

=back

The following functions are defined for fixlist objects:

=over 4

=item silk.B<fixlist_append(>I<fixlist>, I<obj>[, I<obj>...]B<)>

Append data to the fixrec list I<fixlist>.  For all list types each
I<obj> argument may be a L<fixrec|/Fixrec>.  When I<fixlist> is a
subTemplateList or a basicList, the function raises an error when the
L<schema|/Schema> of the fixrec I<obj> does not match the schema of
I<fixlist>.  Additional types for I<obj> are acceptable depending on
the type of I<fixlist>.

When appending to a basicList, each I<obj> may be a fixrec or it may
be a value to append to the basicList.  That is, for each I<obj> that
is not a fixrec the function does the equivalent of creating a fixrec
from I<fixlist>'s schema and setting the value of the first field in
that fixrec to I<obj>:
silk.fixrec(fixlist_get_schema(I<fixlist>),{I<obj>})

When appending to a subTemplateList, each I<obj> may be a fixrec or it
may be a table of key,value pairs to use when creating a fixrec based
on I<fixlist>'s schema.  That is, the function does the equivalent of:
silk.fixrec(fixlist_get_schema(I<fixlist>),I<obj>)

When appending to a subTemplateMultiList, each I<obj> may be a fixrec
or it may be a sequence whose first element is a sequence of
information elements and whose remaining elements are tables.  The
first item in each I<obj> sequence is used to create a schema, and the
remaining tables in each I<obj> sequence are used to create fixrecs
based on that schema.  That is, for each I<obj>, the code does the
equivalent of:

 local s = silk.schema(table.unpack(obj[1]))
 for i = 2, #obj do
   silk.fixlist_append(fixlist, silk.fixrec(s, obj[i]))
 end

=item silk.B<fixlist_count_elements(>I<fixlist>B<)>

Return the number of elements in I<fixlist>.

=item silk.B<fixlist_get_element(>I<fixlist>, I<position>B<)>

Return the fixrec in the fixrec list I<fixlist> at index
I<position>, where 1 is the first element.  Return B<nil> if
I<position> is greater than the number of elements in I<fixlist>

=item silk.B<fixlist_get_schema(>I<fixlist>B<)>

Return the schema used by the elements in I<fixlist> or return
B<nil> if the type of I<fixlist> is C<subTemplateMultiList>.

For a basicList, this function returns an invalid schema that
contains a single information element.  The schema is invalid
because it uses a reserved template identifier (0xFF).

=item silk.B<fixlist_get_semantic(>I<fixlist>B<)>

Return a string describing the relationship among the list elements
in the structured data fixrec I<fixlist>.  (See RFC6313.)  The
returned value is one of

=over 4

=item noneOf

Specifies that none of the elements are actual properties of the
Data Fixrec.

=item exactlyOneOf

Specifies that only a single element from the structured data is an
actual property of the Data Fixrec. This is equivalent to a logical
XOR operation.

=item oneOrMoreOf

Specifies that one or more elements from the list in the structured
data are actual properties of the Data Fixrec. This is equivalent
to a logical OR operation.

=item allOf

Specifies that all of the list elements from the structured data
are actual properties of the Data Fixrec.

=item ordered

Specifies that elements from the list in the structured data are
ordered.

=item undefined

Specifies that the semantic of the list elements is not specified
and that, if a semantic exists, then it is up to the Collecting
Process to draw its own conclusions. The "undefined" structured
data type semantic is the default structured data type semantic.

=back

=item silk.B<fixlist_get_type(>I<fixlist>B<)>

Return a string describing the type structured data in I<fixlist>.
The returned value is one of

=over 4

=item basicList

A list where the elements in the list are a single information
element.

=item subTemplateList

A list where the elements in the list all have the same schema.

=item subTemplateMultiList

A list where the elements in the list may have different schemas.
A subTemplateMultiList may be thought of as a basicList of
subTemplateLists.

=back

=item silk.B<fixlist_iter(>I<fixlist>[, I<fixrec>]B<)>

Return an iterator over the L<fixrec|/Fixrec> objects in the
structure data I<fixlist>.  If the optional I<fixrec> is provided,
the iterator clears that fixrec, fills it with the new data
(ignoring I<fixrec>'s previous L<schema|/Schema>), and returns it
each time rather than creating a new fixrec.

=item silk.B<fixlist_next_element(>I<fixlist>[, I<fixrec>]B<)>

Return the next element from the structured data I<fixlist> as a
L<fixrec|/Fixrec>, or return B<nil> if all elements from I<fixlist>
have been seen.  If the optional I<fixrec> is specified, the
function clears that fixrec (ignoring I<fixrec>'s previous
L<schema|/Schema>), fills it with the new data, and returns it.
Use B<fixlist_reset_iter()> to process the elements in I<fixlist>
again.

=item silk.B<fixlist_reset_iter(>I<fixlist>B<)>

Reset the fixrec list I<fixlist> so that B<fixlist_next_element()>
returns the first element in the list.

=item silk.B<fixlist_set_semantic(>I<fixlist>, I<semantic>B<)>

Specify the relationship among the list elements in the structured
data fixrec I<fixlist>.  The valid values for I<semantic> are given
in the description of B<fixlist_get_semantic()>.

=item silk.B<fixlist_to_string(>I<fixlist>B<)>

Return a unique string designating I<fixlist>.

=back

=head2 Fixrec

A B<fixrec> object represents an IPFIX record or an IPFIX
representation of a SiLK Flow record.  Every fixrec is described by a
L<schema|/Schema>.

The following function creates a fixrec object:

=over 4

=item silk.B<fixrec(>I<schema>[, I<table>]B<)>

Create a zeroed-out fixrec with the L<schema|/Schema> given in
I<schema>.

When the optional I<table> argument is provided, for each
I<key>,I<value> pair in the table call
B<fixrec_set_value(>I<fixrec>,I<key>,I<value>B<)>.  Destroy the
fixrec and raise an error if any field on the fixrec cannot be set.

=back

The following operator-type functions are defined for fixrec objects:

=over 4

=item B<#>I<fixrec>

An alias for
L<silk.B<fixrec_count_fields()>|/"silk.B<fixrec_count_fields(>I<fixrec>B<)>">.

=item I<fixrec>B<[> I<field> | I<position> | I<name> | I<table> B<]>

Get the value for a field from I<fixrec>.  An alias for the two
argument form of
L<silk.B<fixrec_get_value()>|/"silk.B<fixrec_get_value(>I<fixrec>, {I<field> | I<position> | I<name> | I<table>}[, I<notfound>]B<)>">.

=item I<fixrec>B<[> I<field> | I<position> | I<name> | I<table> B<] => I<value>

Set the value for a field in I<fixrec> to I<value>.  An alias for
L<silk.B<fixrec_set_value()>|/"silk.B<fixrec_set_value(>I<fixrec>, {I<field> | I<position> | I<name> | I<table>}, I<value>B<)>">.

=back

The following functions are defined for fixrec objects:

=over 4

=item B<pairs(>I<fixrec>B<)>

Return an iterator designed for the Lua B<for> statement that
iterates over (name, value) pairs of the fixrec in position
order, where name is the string name of the field and value is
that field's value in I<fixrec>.  May be used as
B<for I<name>, I<value> in pairs(I<fixrec>) do...end>

=item silk.B<fixrec_copier(>I<spec>[, I<copy_rest>]B<)>

Return a function which copies data between fixrecs, based on
the given I<spec> table.  The returned function takes a source
fixrec as the first argument, the destination fixrec as the
second argument, and returns the destination fixrec.
Specifically, the returned function (called I<copier> below)
has the following signature:

I<dest_rec> = I<copier>(I<source_rec>, I<dest_rec>)

The spec table contains key,value pairs where the key is the
destination field and the value is either a source field or a
function.  Specifically:

=over 4

=item I<destination_ie_specifier> = I<source_ie_specifier>

Set the I<destination_ie_specifier> field on the destination
fixrec to the value of the I<source_ie_specifier> field on the
source fixrec.

=item I<destination_ie_specifier> = I<function>

Set the I<destination_ie_specifier> field on the destination
fixrec to the result of calling I<function> with the source
fixrec as the only argument.

=back

Each I<ie_specifier> may be anything accepted by the
L<silk.B<schema()>|/"silk.B<schema(>[I<elem>[, ...]]B<)>">
function.

If I<copy_rest> is present and true (not nil or false), the
copier will copy any field that is in both the source and
destination fixrec that is not already specified in the
I<spec>.

As an example, the following I<spec> copies the octetDeltaCount
field from the source to the octetTotalCount field on the
destination, copies the packetDeltaCount field (IE 2) from the
source to the packetTotalCount field on the destination, and
computes a value for flowDurationMilliseconds field

 {
   octetTotalCount = "octetDeltaCount",
   packetTotalCount = 2,
   flowDurationMilliseconds = function (r)
       return silk.datetime_difference(r.flowEndMilliseconds,
                                       r.flowStartMilliseconds)
   end
 }

=item silk.B<fixrec_copy(>I<fixrec>[, I<schema> | I<dest_fixrec>]B<)>

Return a copy of I<fixrec>.

When only one argument is present, a new fixrec is created that
conforms to I<fixrec>'s L<schema|/Schema>, the data from I<fixrec>
is copied into the new fixrec, and the new fixrec is returned.

With the optional I<schema> argument, a new fixrec is created that
conforms to that L<schema|/Schema> object, the data is copied
between the two fixrecs, and the new fixrec is returned.

With the optional I<dest_fixrec> argument, which may have a
different underlying schema than I<fixrec>, the data from I<fixrec>
is copied into I<dest_fixrec>, and I<dest_fixrec> is returned.

When copying across different schemas, the function takes each
field in the destination schema and attempts to find a matching
field in I<fixrec>'s schema.  If such a field is found, the value
of that field in I<fixrec> is copied into the destination fixrec.
If there are multiple instances of a field, the first field in
I<fixrec> is copied to the first destination field, the second to
the second, et cetera.  Fields in I<dest_fixrec> that are not found
in I<fixrec> are left untouched.  If any destination field is
smaller than the matching source field, the value is truncated.

=item silk.B<fixrec_count_fields(>I<fixrec>B<)>

Return the number of fields in I<fixrec>.

=item silk.B<fixrec_get_etime(>I<fixrec>[, I<export_time>]B<)>

Return a L<datetime|/Datetime> representing the end time of
I<fixrec>.  The optional argument is the export time returned
by
L<silk.B<stream_read()>|/"silk.B<stream_read(>I<stream>[, I<arg>]B<)>">.
This function examines the fixrec's schema to determine which
of the several possible IPFIX time fields are being used.

=item silk.B<fixrec_get_schema(>I<fixrec>B<)>

Return the L<schema|/Schema> associated with I<fixrec>.

=item silk.B<fixrec_get_stime(>I<fixrec>[, I<export_time>]B<)>

Return a L<datetime|/Datetime> representing the start time of
I<fixrec>.  The optional argument is the export time returned
by
L<silk.B<stream_read()>|/"silk.B<stream_read(>I<stream>[, I<arg>]B<)>">.
This function examines the fixrec's schema to determine which
of the several possible IPFIX time fields are being used.

=item silk.B<fixrec_get_value(>I<fixrec>, {I<field> | I<position> | I<name> | I<table>}[, I<notfound>]B<)>

Get the value for a field from I<fixrec>.  When the second argument
is not a L<field|/Field>, the function uses
L<silk.B<schema_get_field()>|/"silk.B<schema_get_field(>I<schema>, {I<field> | I<position> | I<name> | I<table>}B<)>">
to get the field object from I<fixrec>'s L<schema|/Schema>.

When only two arguments are provided, the behavior when the field
is not present on I<fixrec>'s schema depends on the type of the
second argument.  When the second argument is a position (i.e.,
numeric), the function returns B<nil>.  Otherwise, the function
raises an error.

Usually when the field is not present on I<fixrec>'s schema and a
third argument is provided (shown as I<notfound> above), that value
is returned.  However, when B<schema_get_field()> raises an error
because the form of the I<table> argument is invalid, any
I<notfound> argument is ignored.

=item silk.B<fixrec_set_value(>I<fixrec>, {I<field> | I<position> | I<name> | I<table>}, I<value>B<)>

Set the value for a field in I<fixrec> to I<value>.  When the
second argument is not a L<field|/Field>, the function uses
L<silk.B<schema_get_field()>|/"silk.B<schema_get_field(>I<schema>, {I<field> | I<position> | I<name> | I<table>}B<)>">
to get the field object from I<fixrec>'s L<schema|/Schema>.

Raise an error if field if not present on I<fixrec>'s schema or if
there is an issue setting the field to I<value>.

=item silk.B<fixrec_to_string(>I<fixrec>[, I<sep>]B<)>

Return a string consisting of the values of the fields of
I<fixrec> in position order.  The values are separated by the
string I<sep> or by C<|> when I<sep> is B<nil>.

=back

=head2 Information Model

Currently all of SiLK uses a single IPFIX information model.  This
information model is not directly accessible from Lua.

The following function is defined to manipulate the information model:

=over 4

=item silk.B<infomodel_augment(>I<ie_sequence>B<)>

Modify the global information model to include the information
elements (IEs) described in I<ie_sequence>.

Each element in the sequence should be a table, and each table may
contain the following keys and values (the B<name>, B<elementId>,
B<length>, and B<dataType> keys are required):

=over 4

=item name

The canonical name of the IE.  Required.

=item elementId

The element identifier as an integer between 1 and 61439 inclusive.
Required.

=item enterpriseId

The Private Enterprise Number (PEN) as an integer between 0 and
4294967295 inclusive.  A value of 0 or B<nil> is equivalent to
having no PEN---that is, the standard information model.  Defaults
to 0.

=item length

The length of this element as a number of octets or the string
C<varlen> for a variable sized element.  Required.

=item dataType

The data type of the IE.  Required.  Must be one of the following
strings:

=over 4

=item *

octetArray

=item *

unsigned8

=item *

unsigned16

=item *

unsigned32

=item *

unsigned64

=item *

signed8

=item *

signed16

=item *

signed32

=item *

signed64

=item *

float32

=item *

float64

=item *

boolean

=item *

macAddress

=item *

string

=item *

dateTimeSeconds

=item *

dateTimeMilliseconds

=item *

dateTimeMicroseconds

=item *

dateTimeNanoseconds

=item *

ipv4Address

=item *

ipv6Address

=item *

basicList

=item *

subTemplateList

=item *

subTemplateMultiList

=back

=item description

A textual description of the IE.  Defaults to no description.

=item dataTypeSemantics

The data type semantic value for the IE.  Defaults to having no
semantic value (C<default>).  If specified, must be one of the
following strings:

=over 4

=item *

default

=item *

quantity

=item *

totalCounter

=item *

deltaCounter

=item *

identifier

=item *

flags

=item *

list

=back

=item units

The units that the given quantity or counter represents.  Defaults
to not having a units value (C<none>).  If specified, must be one
of the following strings:

=over 4

=item *

none

=item *

bits

=item *

octets

=item *

packets

=item *

flows

=item *

seconds

=item *

milliseconds

=item *

microseconds

=item *

nanoseconds

=item *

fourOctetWords (``4-octet words'' in RFC5610)

=item *

messages

=item *

hops

=item *

entries

=item *

frames

=back

=item rangemin

The minimum numeric value for this element.  Defaults to 0.  Not
useful for non-numeric elements or without a corresponding non-zero
rangemax item.

=item rangemax

The maximum numeric value for this element.  Defaults to 0.  Not
useful for non-numeric elements.

=item endian

Whether endianness needs to be considered when transcoding this
element.  This should be either B<true> or B<false>.  Defaults to
an appropriate value based on the dataType.

=item reversible

Whether this element can have a reverse value (as in a bi-flow).
This should be either B<true> or B<false>.  Defaults to B<false>.

=back

=back

=head2 IP Address

An B<ipaddr> object represents an IP address.

The following function creates an ipaddr object:

=over 4

=item silk.B<ipaddr(>I<address>B<)>

Return an ipaddr based on I<address>.  I<address> must be a string
representation of either an IPv4 or IPv6 address, or an ipaddr
object.

=back

The following functions are defined for ipaddr objects:

=over 4

=item silk.B<ipaddr_country_code(>I<ipaddr>B<)>

Return the two character country code associated with I<ipaddr>.
If no country code is associated with I<ipaddr>, return B<nil>.
The country code association is initialized by the
L<silk.B<init_country_codes()>|/"silk.B<init_country_codes(>[I<filename>]B<)>">
function.  Calling this function before calling
B<init_country_codes()> causes B<init_country_codes()> to be
invoked with no argument.

=item silk.B<ipaddr_from_bytes(>I<bytes>B<)>

Create an ipaddr from a string of bytes.  For an IPv4 address,
I<bytes> must be a 4-byte string in network byte order.  For an
IPv6 address, I<bytes> must be a 16-byte string in network byte
order.  Note: This function converts from a byte representation of
an IP address to an ipaddr object, not from a string
representation.

=item silk.B<ipaddr_ipv4_from_bytes(>I<bytes>B<)>

Create an IPv4 ipaddr from a string of four bytes.

=item silk.B<ipaddr_ipv6_from_bytes(>I<bytes>B<)>

Create an IPv6 ipaddr from a string of 16 bytes.

=item silk.B<ipaddr_is_ipv6(>I<ipaddr>B<)>

Return B<true> if I<ipaddr> is an IPv6 address, B<false> if it is
an IPv4 address.

=item silk.B<ipaddr_mask(>I<ipaddr>, I<mask>B<)>

Return a copy of I<ipaddr> masked by the ipaddr I<mask>.

When both addresses are either IPv4 or IPv6, applying the mask is
straightforward.

If I<ipaddr> is IPv6 but I<mask> is IPv4, I<mask> is converted to
IPv6 and then the mask is applied.  This may result in an odd
result.

If I<ipaddr> is IPv4 and I<mask> is IPv6, I<ipaddr> remains an
IPv4 address if masking I<mask> with C<::ffff:0000:0000> results in
C<::ffff:0000:0000>, (namely, if bytes 10 and 11 of I<mask> are
0xFFFF).  Otherwise, I<ipaddr> is converted to an IPv6 address and
the mask is performed in IPv6 space, which may result in an odd
result.

=item silk.B<ipaddr_mask_prefix(>I<ipaddr>, I<prefix>B<)>

Return a copy of I<ipaddr> masked by the high I<prefix> bits.  All
bits below the I<prefix>th bit are set to zero.  The maximum
value for I<prefix> is 32 for an IPv4 address, and 128 for an
IPv6 address.

=item silk.B<ipaddr_octets(>I<ipaddr>B<)>

Return a sequence of the octets of I<ipaddr>.  This is a sequence
of four integers for an IPv4 address and a sequence of sixteen
integers for an IPv6 address.  In both cases,
B<ipaddr_octets(I<ipaddr>)[1]> is the most significant byte of the
address.

=item silk.B<ipaddr_to_bytes(>I<ipaddr>B<)>

Return a string which represents the raw bytes of the I<ipaddr> in
network byte order.  The resulting string is of length 4 for
IPv4 addresses, and of length 16 for IPv6 addresses.  The resulting
string my contain embedded zeroes.

=item silk.B<ipaddr_to_int(>I<ipaddr>B<)>

Return the integer representation of I<ipaddr>.  For an IPv4
address, this is a 32-bit integer.  For an IPv6 address, this is a
floating-point approximation of the actual 128-bit number.

=item silk.B<ipaddr_to_ipv4(>I<ipaddr>B<)>

If I<ipaddr> is an IPv4 address, return I<ipaddr>.  If I<ipaddr> is
in the ::ffff:0:0/96 prefix, return a new ipaddr containing the
IPv4 address.  Otherwise, return B<nil>.

=item silk.B<ipaddr_to_ipv6(>I<ipaddr>B<)>

If I<ipaddr> is an IPv6 address, return I<ipaddr>.  Otherwise,
return a new ipaddr mapping I<ipaddr> into the ::ffff:0:0/96
prefix.

=item silk.B<ipaddr_to_string(>I<ipaddr>[, I<form>])B<)>

Return a human-readable representation of I<ipaddr>.  If the string
I<form> is supplied, it specifies how the IP address is
converted to a string.  I<form> defaults to C<canonical>.  I<form>
should be one of:

=over 4

=item canonical

Return the address in canonical form: dotted quad for IPv4
(C<127.0.0.1>) and hexadectet for IPv6 (C<2001:db8::1>).  Note that
IPv6 addresses in ::ffff:0:0/96 and some IPv6 addresses in ::/96
are returned as a mixture of IPv6 and IPv4.

=item zero-padded

Return the address in canonical form, but fully expand every octet
or hexadectet with the maximum number of zeros.  The addresses
C<127.0.0.1> and C<2001:db8::1> are returned as C<127.000.000.001>
and C<2001:0db8:0000:0000:0000:0000:0000:0001>, respectively.

=item decimal

Return a string showing the address as an integer in decimal
format.  The addresses C<127.0.0.1> and C<2001:db8::1> are returned
as C<2130706433> and C<42540766411282592856903984951653826561>,
respectively.

=item hexadecimal

Return a string showing the address as an integer in hexadecimal
format.  The addresses C<127.0.0.1> and C<2001:db8::1> are returned
as C<7f000001> and C<20010db8000000000000000000000001>,
respectively.

=item force-ipv6

Return the addresses in the canonical form for IPv6 without using
any IPv4 notation.  Any IPv4 address is mapped into the
::ffff:0:0/96 netblock.  The addresses C<127.0.0.1> and
C<2001:db8::1> are returned as C<::ffff:7f00:1> and C<2001:db8::1>,
respectively.

=back

=item silk.B<ipv4addr(>I<addr>B<)>

Create an IPv4 ipaddr from an IP address string, integer, or
ipaddr.  Raises an error if the given argument cannot be converted
to an IPv4 address.

=item silk.B<ipv6addr(>I<addr>B<)>

Create an IPv6 ipaddr from an IP address string or ipaddr.

=back

=head2 IPset

An B<ipset> object represents a SiLK IPset.

The following function creates an ipset object:

=over 4

=item silk.B<ipset(>[I<element_array>]B<)>

Create an IPset.

Without any arguments, create an empty IPset.

With an I<element_array> argument, an empty IPset is
created, and then each element in the I<element_array> is
added to the IPset using the B<ipset_add> function.

=back

The following operator-type functions are defined for ipset objects:

=over 4

=item B<#>I<ipset>

An alias for
L<silk.B<ipset_cardinality()>|/"silk.B<ipset_cardinality(>I<ipset>B<)>">.

=item I<ipset>B<[> I<element> B<]>

Return B<true> if I<ipset> contains the any of the IP addresses in
I<element>.  Return B<false> otherwise.  I<element> may be an
L<ipaddr|/IP Address>, an ipset, an L<ipwildcard|/IP Wildcard>, or
an ipwildcard string.

=item I<ipset>B<[> I<element> B<] => I<bool>

Add or remove the IP addresses referenced by I<element> to or from
I<ipset>.  If I<bool> is C<true>, the addresses are added; if
C<false>, the addresses are removed. I<element> may be an
L<ipaddr|/IP Address>, an ipset, an L<ipwildcard|/IP Wildcard>, or
an ipwildcard string.

=back

The following functions are defined for ipset objects:

=over 4

=item silk.B<ipset_add(>I<ipset>[, I<element>[, ...]]B<)>

Add each I<element> to the I<ipset>.  Each I<element> may be an
L<ipaddr|/IP Address>, an L<ipwildcard|/IP Wildcard>, an
ipwildcard string, or an ipset.

=item silk.B<ipset_add_range(>I<ipset>, I<start>, I<end>B<)>

Add all IP addresses from I<start> to I<end>, inclusive, to
I<ipset>.  I<start> and I<end> must be either
L<ipaddr objects|/IP Address> or IP address strings.  An error is
raised if I<end> is less than I<start>.

=item silk.B<ipset_cardinality(>I<ipset>B<)>

Return the cardinality of I<ipset>.

=item silk.B<ipset_cidr_iter(>I<ipset>[, I<ipv6_policy>]B<)>

Return an iterator over the CIDR blocks in I<ipset>.  Each iteration
returns two values, the first of which is the first
L<IP address|/IP Address> in the block, the second of which is the
prefix length of the block.  May be used as
B<for I<addr>, I<prefix> in silk.ipset_cidr_iter(I<ipset>) do...end>.

The I<ipv6_policy> parameter is handled as in silk.B<ipset_iter()>.

=item silk.B<ipset_clear(>I<ipset>B<)>

Remove all IP addresses from I<ipset> and return I<ipset>.

=item silk.B<ipset_contains(>I<ipset>, I<addr>B<)>

Return B<true> if I<ipset> contains I<addr>.  Return B<false>
otherwise.  I<addr> may be an L<ipaddr|/IP Address> or a string
representation of an ipaddr.

=item silk.B<ipset_convert_v4(>I<ipset>B<)>

Convert I<ipset> to an IPv4 IPset.  Return I<ipset>.  If I<ipset>
contains IPv6 addresses outside of the ::ffff:0:0/96 prefix, raise
an error and leave I<ipset> unchanged.

=item silk.B<ipset_convert_v6(>I<ipset>B<)>

Convert I<ipset> to an IPv6 IPset.  Return I<ipset>.

=item silk.B<ipset_copy(>I<ipset>B<)>

Return a new IPset with a copy of I<ipset>.

=item silk.B<ipset_create_v4(>B<)>

Return a new IPset optimized to contain IPv4 addresses.

=item silk.B<ipset_create_v6(>B<)>

Return a new IPset that can contain IPv4 or IPv6 addresses.

=item silk.B<ipset_difference(>I<ipset>, I<other>[, ...]B<)>

Return a new IPset containing the IP addresses in I<ipset> but
not in I<other>s.  I<other>s may contain ipsets,
L<ipwildcards|/IP Wildcard>, ipwildcard strings, or arrays of
L<ipaddrs|/IP Address> and ipwildcard strings.

=item silk.B<ipset_difference_update(>I<ipset>, I<other>[, ...]B<)>

Remove from I<ipset> any IP addresses found in I<other>s.
I<other>s may contain ipsets, L<ipwildcards|/IP Wildcard>,
ipwildcard strings, or arrays of L<ipaddrs|/IP Address> and
ipwildcard strings.  Return I<ipset>.

=item silk.B<ipset_discard(>I<ipaddr>[, I<other>[, ...]]B<)>

Remove from I<ipset> any IP addresses found in I<other>s.
I<other>s may contain ipsets, L<ipwildcards|/IP Wildcard>,
ipwildcard strings, or L<ipaddrs|/IP Address>.

=item silk.B<ipset_intersection(>I<ipset>, I<other>[, ...]B<)>

Return a new IPset containing the IP addresses common to
I<ipset> and I<other>s.  I<other>s may contain ipsets,
L<ipwildcards|/IP Wildcard>, ipwildcard strings, or arrays of
L<ipaddrs|/IP Address> and ipwildcard strings.

=item silk.B<ipset_intersection_update(>I<ipset>, I<other>[, ...]B<)>

Remove from I<ipset> any IP addresses that do not appear in
I<other>s.  I<other>s may be ipsets, L<ipwildcards|/IP Wildcard>,
ipwildcard strings, or arrays of L<ipaddrs|/IP Address> and
ipwildcard strings.  Return I<ipset>.

=item silk.B<ipset_is_disjoint(>I<ipset>, I<element>B<)>

Return B<true> when none of the IP addresses in I<element> are
present in I<ipset>.  Return B<false> otherwise.  I<element>
may be an L<ipaddr|/IP Address>, an L<ipwildcard|/IP Wildcard>,
an ipwildcard string, or an ipset.

=item silk.B<ipset_is_ipv6(>I<ipset>B<)>

Return B<true> if I<ipset> is a set of IPv6 addresses, and B<false>
if it a set of IPv4 addresses.  For the purposes of this method,
IPv4-in-IPv6 addresses (that is, addresses in the ::ffff:0:0/96
prefix) are considered IPv6 addresses.

=item silk.B<ipset_is_subset(>I<ipset1>, I<ipset2>B<)>

Return B<true> if every IP address in I<ipset1> is also in
I<ipset2>.  Return B<false> otherwise.

=item silk.B<ipset_is_superset(>I<ipset1>, I<ipset2>B<)>

Return B<true> if every IP address in I<ipset2> is also in
I<ipset1>.  Return B<false> otherwise.

=item silk.B<ipset_iter(>I<ipset>[, I<ipv6_policy>]B<)>

Return an iterator over the L<IP addresses|/IP Address> in
I<ipset>.  May be used as
B<for I<addr> in silk.ipset_iter(I<ipset>) do...end>.

I<ipv6_policy> is a string that determines how IP addresses in the
set are returned.  The default is C<mix>, and valid values are:

=over 4

=item ignore

Return only IPv4 addresses, ignoring any IPv6 addresses.

=item asv4

Return any IPv6 addresses in the ::ffff:0:0/96 prefix as IPv4
addresses and ignore all other IPv6 addresses.

=item mix

Return all IP addresses normally.

=item force

Return all addresses as IPv6 addresses, mapping the IPv4 addresses
into the ::ffff:0:0/96 prefix.

=item only

Return only IPv6 addresses, ignoring any IPv4 addresses.

=back

=item silk.B<ipset_load(>I<filename>B<)>

Load and return an IPset from the file I<filename>.

=item silk.B<ipset_remove(>I<ipaddr> I<other>B<)>

Remove from I<ipset> any IP addresses found in I<other>.  Raise
an error if no IP address in I<other> is in I<ipset>.  I<other>
may be an ipset, an L<ipwildcard|/IP Wildcard>, an ipwildcard
string, or an L<ipaddr|/IP Address>.

=item silk.B<ipset_save(>I<ipset>, I<filename>B<)>

Save the contents of I<ipset> in the file I<filename>.

=item silk.B<ipset_symmetric_difference(>I<ipset>, I<other>[, ...]B<)>

Return a new IPset containing the IP addresses in either
I<ipset> or in I<other> but not in both.  I<other>s may contain
ipsets, L<ipwildcards|/IP Wildcard>, ipwildcard strings, or
arrays of L<ipaddrs|/IP Address> and ipwildcard strings.

=item silk.B<ipset_symmetric_difference_update(>I<ipset>, I<other>[, ...]B<)>

Update I<ipset>, keeping the IP addresses found in I<ipset> or
in I<other> but not in both. I<other>s may contain ipsets,
L<ipwildcards|/IP Wildcard>, ipwildcard strings, or arrays of
L<ipaddrs|/IP Address> and ipwildcard strings.  Return
I<ipset>.

=item silk.B<ipset_to_string(>I<ipset>B<)>

Return a unique string designating I<ipset>.

=item silk.B<ipset_union(>I<ipset>, I<other>[, ...]B<)>

Return a new IPset containing the IP addresses in I<ipset> and
all I<other>s.  I<other>s may contain ipsets,
L<ipwildcards|/IP Wildcard>, ipwildcard strings, or arrays of
L<ipaddrs|/IP Address> and ipwildcard strings.

=item silk.B<ipset_update(>I<ipset>, I<other>[, ...]B<)>

Add to I<ipset> any IP addresses found in I<other>s.  I<other>s
may contain ipsets, L<ipwildcards|/IP Wildcard>, ipwildcard
strings, or arrays of L<ipaddrs|/IP Address> and ipwildcard
strings.  Return I<ipset>.

=back

=head2 IP Wildcard

An B<ipwildcard> object represents a CIDR block or a SiLK IP wildcard
address set.

The following function creates an ipwildcard object:

=over 4

=item silk.B<ipwildcard(>I<wildcard>B<)>

Return a new ipwildcard.  The string I<wildcard> can be an IP
address, an IP with a CIDR notation, an integer, an integer with a
CIDR designation, or an entry in SiLK wildcard notation.  In SiLK
wildcard notation, a wildcard is represented as an IP address in
canonical form with each octet (IPv4) or hexadectet (IPv6)
represented by one of following: a value, a range of values, a
comma separated list of values and ranges, or the character 'x'
used to represent the entire octet or hexadectet.  The I<wildcard>
element can also be an ipwildcard, in which case a duplicate
reference is returned.

=back

The following operator-type function is defined for ipwildcard
objects:

=over 4

=item I<ipwildcard>B<[> I<element> B<]>

An alias for
L<silk.B<ipwildcard_contains()>|/"silk.B<ipwildcard_contains(>I<ipwildcard>, I<element>B<)>">.

=back

The following functions are defined for ipwildcard objects:

=over 4

=item silk.B<ipwildcard_cidr_iter(>I<ipwildcard>[, I<ipv6_policy>]B<)>

Similar to silk.B<ipwildcard_iter()>, but return an iterator over
the CIDR blocks in I<ipwildcard>.  Each iteration returns two
values, the first of which is the first L<IP address|/IP Address>
in the block, the second of which is the prefix length of the
block.  May be used as
B<for I<addr>, I<prefix> in silk.ipwildcard_cidr_iter(I<ipwildcard>) do...end>.

=item silk.B<ipwildcard_contains(>I<ipwildcard>, I<element>B<)>

Return B<true> if I<ipwildcard> contains the IP address in
I<element>.  Return B<false> otherwise.  I<element> can be an
L<ipaddr|/IP Address> or an ipaddr string.

=item silk.B<ipwildcard_is_ipv6(>I<ipwildcard>B<)>

Return B<true> if I<ipwildcard> represents a block of IPv6
addresses, B<false> if it represents IPv4 addresses.

=item silk.B<ipwildcard_iter(>I<ipwildcard>[, I<ipv6_policy>]B<)>

Return an iterator over the IP addresses in I<ipwildcard>.  May be
used as
B<for I<addr> in silk.ipwildcard_iter(I<ipwildcard>) do...end>.

By default or when the second argument, I<ipv6_policy>, is C<mix>,
the iterator returns IPv6 addresses for an IPv6 wildcard and IPv4
addresses for an IPv4 wildcard.

If I<ipv6_policy> is C<force> the addresses returned are always
IPv6 addresses.  For an IPv4 wildcard, the addresses are mapped
into the ::ffff:0:0/96 netblock.

If I<ipv6_policy> is C<asv4>, the addresses returned are always
IPv4 and, for an IPv6 wildcard, only the IPs in the ::ffff:0:0/96
netblock are visited.

If I<ipv6_policy> is C<ignore>, the iterator returns no IPs when
B<ipwildcard_is_ipv6()> returns true.

If I<ipv6_policy> is C<only>, the iterator returns no IPs when
I<ipwildcard_is_ipv6()> returns false.

=item silk.B<ipwildcard_to_string(>I<ipwildcard>B<)>

Return the string that was used to construct I<ipwildcard>.

=back

=head2 Prefix Map

A B<pmap> object represents a SiLK prefix map.  A prefix map typically
maps ranges of IP addresses to strings, though a prefix map can also
be used to map a ranges or protocol/port pairs to strings.

The following functions create a pmap object:

=over 4

=item silk.B<pmap(>I<filename>B<)>

Load a prefix map from I<filename>.

=item silk.B<pmap_load(>I<filename>B<)>

Load a prefix map from I<filename>.

=back

The following operator-type function is defined for pmap objects:

=over 4

=item I<pmap>B<[> I<element> B<]>

An alias for the two-argument form of
L<silk.B<pmap_get()>|/"silk.B<pmap_get(>I<pmap>, I<element>B<)>">.

=back

The following functions are defined for pmap objects:

=over 4

=item silk.B<pmap_get(>I<pmap>, I<element>B<)>

Return the label the prefix map associates with I<element>.
I<element> may be an L<ipaddr|/IP Address> or a 2-element sequence
where the first element is a protocol number and the second element
is a port number.

=item silk.B<pmap_get(>I<pmap>, I<protocol>, I<port>B<)>

Return the label the prefix map associates with proto-port pair
I<protocol>, I<port>.

=item silk.B<pmap_get_content_type(>I<pmap>B<)>

Return the content type of I<pmap> as a string.  The result is one
of C<IPv4-address>, C<IPv6-address>, or C<proto-port>.

=item silk.B<pmap_get_values(>I<pmap>B<)>

Return a sequence of the labels defined by I<pmap>.

=item silk.B<pmap_iterranges(>I<pmap>B<)>

Return an iterator that iterates over ranges of contiguous
values with the same label.

If I<pmap> is an IP address map, each iteration returns three
values, (I<start>, I<end>, I<label>), where I<start> is the first
L<ipaddr|/IP Address> of the range, I<end> is the last ipaddr of
the range, and I<label> is the label for that range.

If I<pmap> is a proto-port map, each iteration returns five values,
(I<start_proto>, I<start_port>, I<end_proto>, I<end_port>,
I<label>), where I<start_proto> and I<start_port> represent the
first element of the range, I<end_proto> and I<end_port> represent
the last element of the range, and I<label> is the label for that
range.

=item silk.B<pmap_to_string(>I<pmap>B<)>

Return a unique string designating I<pmap>.

=back

=head2 RWRec

An rwrec represents a SiLK Flow record.  An RWRec has a fixed set of
elements in a fixed layout, and it may also have a Lua table
containing additional key-value pairs that augment the record.  This
table is referred to as I<sidecar> data.

The following functions create an rwrec object:

=over 4

=item silk.B<rwrec(>[I<table>]B<)>

Create an rwrec object.  With no argument or a B<nil> as an
argument, create an empty rwrec.  When I<table> is provided, the
new record is initialized by calling
L<silk.B<rwrec_set_value()>|/"silk.B<rwrec_set_value(>I<rwrec>, I<name>, I<value>B<)>">
for each key-value pair in I<table>.  Raise an error if the
argument is not a table or when a key is not a valid rwrec field
name.

=item silk.B<rwrec_create(>[I<table>]B<)>

Create an rwrec object.  An alias for
L<silk.B<rwrec()>|/"silk.B<rwrec(>[I<table>]B<)>">

=back

The following operator-type functions are defined for rwrec objects:

=over 4

=item I<rwrec>B<[> I<name> B<]>

Get the value of the I<name> field on the RWRec I<rwrec>. An alias
for
L<silk.B<rwrec_get_value()>|/"silk.B<rwrec_get_value(>I<name>B<)>">

=item I<rwrec>B<[> I<name> B<]> = I<value>

Set the value for the field I<name> in I<rwrec> to I<value>.  An
alias for
L<silk.B<rwrec_set_value()>|/"silk.B<rwrec_set_value(>I<rwrec>, I<name>, I<value>B<)>">.

=back

The following functions are defined for rwrec objects:

=over 4

=item B<pairs(>I<rwrec>B<)>

Return an iterator designed for the Lua B<for> statement that
iterates over (name, value) pairs of I<rwrec>, where name is the
string name of the field and value is that field's value in
I<rwrec>.  May be used as
B<for I<name>, I<value> in pairs(I<rwrec>) do...end>

=item silk.B<rwrec_as_table(>I<rwrec>B<)>

Return a table representing the contents of I<rwrec>.  The keys of
the table are the strings listed in the documentation of
L<silk.B<rwrec_get_value()>|/"silk.B<rwrec_get_value(>I<name>B<)>">

=item silk.B<rwrec_clear(>I<rwrec>B<)>

Clear all values in the RWRec object I<rwrec>.

=item silk.B<rwrec_copy(>I<rwrec>B<)>

Create a new RWRec that is a copy of the RWRec object I<rwrec>.

B<NOTE:> Currently the sidecar table is not included in the copy.

=item silk.B<rwrec_get_value(>I<name>B<)>

Get the value of the I<name> field on the RWRec I<rwrec>.  I<name>
must be one of the following string values:

=over 4

=item sip

source IP address, an L<ipaddr|/IP Address> object

=item dip

destination IP address, an L<ipaddr|/IP Address> object

=item sport

source port for TCP and UDP, or equivalent, a number

=item dport

destination port for TCP and UDP, or equivalent, a number

=item protocol

IP protocol, a number

=item packets

packet count, a number

=item bytes

byte count, a number

=item flags

bit-wise OR of the TCP flags seen on all packets in the flow, a
number. Use the functions in L</TCP Flags> to convert the number to
a string.

=item initial_tcpflags

TCP flags seen on the first packet in the flow, a number

=item session_tcpflags

bit-wise OR of the TCP flags seen on the second through final
packets in the flow, a number

=item stime

starting time of flow, a L<datetime|/Datetime> object

=item duration

duration of flow, a floating point number representing seconds

=item etime

end time of flow, a L<datetime|/Datetime> object

=item sensor

name of the sensor at the collection point, a string

=item sensor_id

numeric ID of the sensor at the collection point, a number

=item classname

name of the class of sensor at the collection point, a string

=item typename

name of the type of sensor at the collection point, a string

=item classtype

name that represents the unique class/type pair, a string

=item classtype_id

number representing the unique class/type pair, a number

=item icmptype

the ICMP type value for ICMP or ICMPv6 flows and 0 for non-ICMP
flows, a number

=item icmpcode

the ICMP code value for ICMP or ICMPv6 flows and 0 for non-ICMP
flows, a number

=item input

router SNMP input interface, a number

=item output

router SNMP output interface, a number

=item nhip

router next hop IP, an L<ipaddr|/IP Address> object

=item application

guess as to the content of the flow, a number

=item attributes

flow attributes set by the flow generator, a number. Use the
functions in L</Attributes> to convert the number to a string.

=item timeout_killed

whether the flow generator prematurely created this flow for a
long-running connection due to a timeout, a boolean.  This value is
a member of the attributes field.

=item timeout_started

whether the flow generator created this flow as a continuation of
long-running connection, where the previous flow for this
connection met a timeout, a boolean.  This value is a member of the
attributes field.

=item uniform_packets

whether all the packets that this flow record represents were
exactly the same size, a boolean.  This value is a member of the
attributes field.

=item sidecar

additional values that augment this rwrec, a table or nil when not
present

=back

=item silk.B<rwrec_is_icmp(>I<rwrec>B<)>

Return B<true> if the protocol of I<rwrec> is 1 (ICMP) or if the
protocol of I<rwrec> is 58 (ICMPv6) and
L<silk.B<rwrec_is_ipv6()>|/"silk.B<rwrec_is_ipv6(>I<rwrec>B<)>">
is B<true>. Return B<false> otherwise.

=item silk.B<rwrec_is_ipv6(>I<rwrec>B<)>

Return B<true> if I<rwrec> contains IPv6 addresses. Return B<false>
otherwise.

=item silk.B<rwrec_is_web(>I<rwrec>B<)>

Return C<true> if I<rwrec> can be represented as a web record, or
B<false> otherwise.  A record can be represented as a web record if
the protocol is TCP (6) and either the source or destination port
is one of 80, 443, or 8080.

=item silk.B<rwrec_set_value(>I<rwrec>, I<name>, I<value>B<)>

Set the value for the field I<name> in I<rwrec> to I<value>.
I<name> is one of the strings specified in the documentation for
L<silk.B<rwrec_get_value()>|/"silk.B<rwrec_get_value(>I<name>B<)>">
except C<classname> and C<typename>.

=item silk.B<rwrec_to_ipv4(>I<rwrec>B<)>

Return a new copy of I<rwrec> with the IP addresses (sip, dip, and
nhip) converted to IPv4. If any of these addresses cannot be
converted to IPv4, (that is, if any address is not in the
::ffff:0:0/96 netblock) return B<nil>.

=item silk.B<rwrec_to_ipv6(>I<rwrec>B<)>

Return a new copy of I<rwrec> with the IP addresses (sip, dip, and
nhip) converted to IPv6. Specifically, the function maps the IPv4
addresses into the ::ffff:0:0/96 netblock.

=item silk.B<rwrec_to_string(>I<rwrec>B<)>

Return a unique string designating I<rwrec>.

=back

=head2 Schema

A B<schema> object represents a sequence of L<field|/Field>s that
describe a L<fixrec|/Fixrec>.  A schema may also be thought of as a
representation of an IPFIX template.

The following function creates a schema object:

=over 4

=item silk.B<schema(>[I<elem>[, ...]]B<)>

Create a schema consisting of the given information elements.  The
type of each element must be one of the following:

=over 4

=item a string

The string should be the name of the information element.

=item an integer

The value should be the elementId of a standard information element.

=item field object

A L<field|/Field> object.

=item table

A table of I<key = value> pairs describing an information element.
The possible keys and their expected values are:

=over 4

=item name

A string containing the name of the information element.

=item enterpriseId

The Private Enterprise Number (PEN) of the information element.
This key requires a corresponding C<elementId> key.

=item elementId

The number of the information element in the Private Enterprise
specified in C<enterpriseId> or a standard information element if
C<enterpriseId> is not specified.

=item field

The L<field|/Field> object.

=item length

The length of the field as an integer, or the string C<varlen> to
indicate a variable-length field.  When not specified, the base
length of the element is used.

=back

=back

=back

The following operator-type functions are defined for schema objects:

=over 4

=item B<#>I<schema>

An alias for
L<silk.B<schema_count_fields()>|/"silk.B<schema_count_fields(>I<schema>B<)>">.

=item I<schema>B<[> I<field> | I<position> | I<name> | I<table> B<]>

Get a L<field|/Field> object from a schema.  An alias for
L<silk.B<schema_get_field()>|/"silk.B<schema_get_field(>I<schema>, {I<field> | I<position> | I<name> | I<table>}B<)>">

=back

The following functions are defined for schema objects:

=over 4

=item B<pairs(>I<schema>B<)>

Return an iterator designed for the Lua B<for> statement that
iterates over (name, L<field|/Field>) pairs of the schema in
position order.  May be used as
B<for I<name>, I<field> in pairs(I<schema>) do...end>

=item silk.B<schema_count_fields(>I<schema>B<)>

Return the number of fields (IEs) in I<schema>.

=item silk.B<schema_get_field(>I<schema>, {I<field> | I<position> | I<name> | I<table>}B<)>

Get a L<field|/Field> from a schema.

If the argument is a field object, return I<field> if it from
I<schema> or B<nil> if it is not from I<schema>.

If the argument is numeric, treat it as a positional index into
I<schema> where 1 is the first position.  Return B<nil> if
I<position> is out of range.

If the argument is a string, assume it is the name of an IE and
search for an IE with I<name> on I<schema>.  When an IE appears
multiple times on I<schema>, I<name> may include a suffix of
C<_I<number>> to return the I<number>th IE whose name is I<name>.
I<name> without the C<_I<number>> suffix is an alias for
C<I<name>_1>.  Return B<nil> if I<name> does not match any field on
I<schema>.

If the argument is a table, it must have an C<elementId> key whose
value is the elementId of the field to return.  The elementId is
assumed to be in the standard information model unless the table
contains an C<enterpriseId> key whose value is not B<nil> or 0.
Raise an error when an C<elementId> key is not present, the value
for C<elementId> or is not a number, or the value for
C<enterpriseId> is not a number and not B<nil>.  Return B<nil> when
the table is valid and the desired field is not present on
I<schema>.

If the argument is any other type of object, return B<nil>.

=item silk.B<schema_get_fields(>I<schema>B<)>

Return a table that contains information about the information
elements in the schema.  This table is doubly-indexed: once by
position (integer), and once by name.  The values are
L<field|/Field> objects.

=item silk.B<schema_get_template_id(>I<schema>B<)>

Return the numeric template id of I<schema>.

=item silk.B<schema_iter(>I<schema>B<)>

Return an iterator over a schema's L<field|/Field> objects.

=item silk.B<schema_to_string(>I<schema>[, I<sep>]B<)>

Return a string consisting of the names of the fields of
I<schema> in position order.  The names are separated by the
string I<sep> or by C<|> when I<sep> is B<nil>.

=back

=head2 Sidecar

The C<sidecar> element of an B<rwrec|/RWRec> object is a Lua table
whose keys are strings and whose values are numbers, strings,
L<datetime|/Datetime> objects, L<ipaddr|/IP Address> objects, or
Lua tables.  A sidecar object represents a description of this
table that is used to encode those fields when writing the record
to a L<stream|/Stream>.

A sidecar description object contains key-value pairs.  The keys on
the sidecar description object should match the keys on the rwrec
object.  Keys in the rwrec's sidecar table that are not present in the
sidecar object are not written to the stream.  The value for a key on
the sidecar object describes the type of that key's value on rwrec
object.

A sidecar object has two states: editable and frozen.  While it is in
editable state, the value for a key on the sidecar object is one of:

=over 4

=item *

a string specifying the type

=item *

a Lua table that describes the type and may include IPFIX information

=item *

a L<sidecar_elem|/Sidecar Element> object that was copied from another
sidecar description

=item *

a Lua table that contains key-value pairs similar to the top-level
table

=back

Once a sidecar is successfully frozen, the values on the sidecar
object become L<sidecar_elem|/Sidecar Element> objects,

The following function creates a sidecar object:

=over 4

=item silk.B<sidecar(>[I<table>]B<)>

Create a sidecar description object.

With no argument or a B<nil> as an argument, create an empty
sidecar description.  If an argument is provided that is not B<nil>
and not a table, raise an error and do not create the sidecar.

When I<table> is provided, new elements are added to the new
sidecar by calling
L<I<sidecar>B<[> I<name> B<]> = I<obj>|/"I<sidecar>B<[> I<name> B<]> = I<obj>">
for each key-object pair in I<table>, and the function returns
either one or two values.  If no errors are detected while adding
the key-object pairs, the new sidecar object is the only return
value.  If an error is detected, two values are returned: the first
is the new, partially constructed sidecar object and the second is
a table containing the keys from I<table> that could not be added.
The value for each key is the error message generated.

=item silk.B<sidecar_create(>[I<table>]B<)>

Create a sidecar description object.  An alias for
L<silk.B<sidecar()>|/"silk.B<sidecar(>[I<table>]B<)>">

=back

The following operator-type functions are defined for sidecar objects:

=over 4

=item B<#>I<sidecar>

Return the number of top-level elements in the sidecar description.

=item I<sidecar>B<[> I<name> B<]>

Get the value associated with I<name> in the sidecar description
object I<sidecar>.

When I<sidecar> is frozen, each value is either a
L<sidecar_elem|/Sidecar Element> or a table of whose keys are
strings and whose values are either L<sidecar_elem|/Sidecar
Element> or another table, et cetera.

When I<sidecar> is editable (not frozen), each value is either a
string specifying the type or a table whose contents may describe a
single element or may represent a more complicated structured
data. (The contents of the table are not checked until the sidecar
description is frozen.

=item I<sidecar>B<[> I<name> B<]> = I<obj>

Set the value of the I<name> element of the sidecar description
I<sidecar> to I<obj>.

Raise an error if I<sidecar> is frozen.  Raise an error unless
I<obj> is one of B<nil>, a string, a table describing a single
element, a table representing a complex element, or a
L<sidecar_elem|/Sidecar Element> taken from another sidecar
description.

=over 4

=item *

If I<obj> is B<nil>, remove I<name> from I<sidecar>, or do nothing
if I<name> is not present on I<sidecar>.

=item *

If I<obj> is a string, it designates a type that is used to encode
the value of the C<sidecar> member of an L<rwrec|/RWRec> object
whose key is I<name>.  The valid values for these type strings and
how the corresponding value on an rwrec is encoded are shown next.
If I<name> is not one of these strings, raise an error.

=over 4

=item uint8

an unsigned integer less than 256 (2^8)

=item uint16

an unsigned integer less than 65,536 (2^16)

=item uint32

an unsigned integer less than 4,294,967,296 (2^32)

=item uint64

an unsigned integer less than 18,446,744,073,709,551,614 (2^64)
B<NOTE>: Values equal to or greater than 2^63 are probably broken
right now.

=item double

a floating point number that fits into a 64-bit IEEE floating point
value

=item string

a variable length string that is not expected to contain binary
values

=item binary

a variable length string that may contain binary values

=item ip4

a L<ipaddr|/IP Address> that holds an IPv4 address

=item ip6

a L<ipaddr|/IP Address> that holds an IPv6 address

=item datetime

a L<datetime|/Datetime> object that represents a date and time

=item boolean

a boolean value

=item empty

no value

=back

=item *

For I<obj> to be a table describing a single element, it must have
a key named C<type> whose value is either one of the strings
immediately above that describe the type of data or the string
C<list> in which case the key C<list_elem_type> should be present
and its value must be one of the strings immediately above.

Two additional keys may be present.  The key C<element_id> should
have an integer value that indicates the IPFIX element id to use
when converting the SiLK Flow record to an IPFIX record (something
that is not currently supported).  The key C<enterprise_id> should
have an integer value giving the IPFIX enterprise id
(a.k.a. Private Enterprise Number (PEN)) for the element id.

B<Note:> The contents of this table are only checked when the
sidecar is frozen.

=item *

For I<obj> to be a table describing a complex (or structured) piece
of data, the table repeats the structure just described: the keys
of the table may be any string (that does not contain binary data)
and value is either a single string, a table describing an element,
or another table, et cetera.

B<Note:> The contents of this table are only checked when the
sidecar is frozen.

=item *

I<obj> may be a L<sidecar_elem|/Sidecar Element> taken from a
different frozen sidecar description object.

=back

=back

The following functions are defined for sidecar objects:

=over 4

=item B<pairs(>I<sidecar>B<)>

Return an iterator designed for the Lua B<for> statement that
iterates over (name, value) pairs of I<sidecar>.  See the
description of
L<I<sidecar>B<[]>|/"I<sidecar>B<[> I<name> B<]>">
for the type of the value.  May be used as
B<for I<name>, I<value> in pairs(I<sidecar>) do...end>

=item silk.B<sidecar_freeze(>I<sidecar>B<)>

Freeze the sidecar description I<sidecar> so that it may no
longer be modified.  The sidecar must be frozen before it can
be added to a L<stream|/Stream>.  Freezing a sidecar changes
the values to L<sidecar_elem|/Sidecar Element> objects.

Do nothing when I<sidecar> is already frozen.

Raise an error when the value for a key does not contain the
required elements.

=item silk.B<sidecar_is_frozen(>I<sidecar>B<)>

Return B<true> if the sidecar description I<sidecar> is frozen;
B<false> otherwise.

=item silk.B<sidecar_to_string(>I<sidecar>B<)>

Return a unique string designating I<sidecar>.

=back

=head2 Sidecar Element

A sidecar element is one of the members of a L<sidecar|/Sidecar>
object.  A sidecar element must have a type.  If the type is C<list>,
then all members of the list are of the same type and the sidecar
element knows that type.  Sidecar elements are created by adding
members to a L<sidecar|/Sidecar>.

=over 4

=item I<sidecar_elem>B<[> I<name> B<]>

Return the value of the I<name> attribute of the sidecar element
I<sidecar_elem>.  I<name> is a string and one of

=over 4

=item type

A string giving the type of data in this element.

=item list_elem_type

When C<type> is C<list>, a string giving the type of elements in
the list, or B<nil> when the element is not a list.

=item enterprise_id

A number representing the IPFIX enterprise id (a.k.a. Private
Enterprise Number (PEN)) that was specified when the sidecar
element was created.

=item element_id

A number representing the IPFIX element id that was specified when
the sidecar element was created.

=back

=back

The following functions are defined for sidecar_elem objects:

=over 4

=item B<pairs(>I<sidecar_elem>B<)>

Return an iterator designed for the Lua B<for> statement that
iterates over (name, value) pairs of a sidecar_elem.  May be used
as
B<for name, value in pairs(I<sidecar_elem>) do...end>

=item silk.B<sidecar_elem_get_element_id(>I<sidecar_elem>B<)>

Return the IPFIX element id that was specified when the sidecar
element I<sidecar_elem> was created.

=item silk.B<sidecar_elem_get_enterprise_id(>I<sidecar_elem>B<)>

Return the IPFIX enterprise id (a.k.a. Private Enterprise Number
(PEN)) that was specified when the sidecar element I<sidecar_elem>
was created.

=item silk.B<sidecar_elem_get_list_elem_type(>I<sidecar_elem>B<)>

Return a string that represents the type of data in the sidecar
list element I<sidecar_elem>.  Return B<nil> when I<sidecar_elem>
is not a list.

=item silk.B<sidecar_elem_get_type(>I<sidecar_elem>B<)>

Return a string that represents the type of data in the sidecar
element I<sidecar_elem>.

=item silk.B<sidecar_elem_to_string(>I<sidecar_elem>B<)>

Return a string representation of the sidecar element
I<sidecar_elem>.

=back

=head2 SiLK Site

Functions for working with the results of parsing the SiLK site
configuration file,  B<silk.conf(5)>.

=over 4

=item silk.site.B<class_sensors(>I<class>B<)>

Return a sequence containing sensors that are in class I<class> (a
string).  Implicitly
calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns
B<false>.  Raise an error if no site file is available or if
I<class> is not a valid class name.

=item silk.site.B<classes(>I<>B<)>

Return a sequence containing valid class names.  Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns
B<false>.  Return an empty sequence if no site file is available.

=item silk.site.B<classtype_from_flowtype(>I<flowtype>B<)>

Return a sequence containing two elements: the I<class> and
I<type> name pair associated with the flowtype I<flowtype> (a
string).
Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no
arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns B<false>.  Raise an error if no site file is available or
if I<flowtype> is not a valid flowtype name.

=item silk.site.B<classtype_from_id(>I<id>B<)>

Return a sequence containing two elements: the I<class> and
I<type> name pair associated with the numeric flowtype ID I<id>.
Implicitly
calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns
B<false>.  Raise an error if no site file is available or if I<id>
is not a valid identifier.

=item silk.site.B<classtype_id(>I<class>B<,> I<type>B<)>

=item silk.site.B<classtype_id(>{I<class>B<,> I<type>}B<)>

Return the numeric flowtype ID associated with I<class> and I<type>
(both strings).
Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no
arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns B<false>. Raise an error if no site file is available, if
I<class> is not a valid class name, or if I<type> is does not name
a valid type in I<class>.

=item silk.site.B<classtypes(>I<>B<)>

Return a sequence containing sequences, where each inner sequence
contains
two elements representing a valid class name and type name.
Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no
arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns B<false>.  Return an empty sequence if no site file is
available.

=item silk.site.B<default_class(>I<>B<)>

Return the default class name.  Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns
B<false>.  Return B<nil> if no site file is available.

=item silk.site.B<default_types(>I<class>B<)>

Return a sequence containing default type names associated with class
I<class> (a string).
Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no
arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns B<false>.  Raise an error if no site file is available or
if I<class> is not a valid class name.

=item silk.site.B<flowtype_from_classtype(>I<class>, I<type>B<)>

=item silk.site.B<flowtype_from_classtype(>{I<class>, I<type>}B<)>

Return the flowtype name associated with I<class> and I<type> (both
strings).
Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no
arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns B<false>.  Raise an error if no site file is available, if
I<class> is not a valid class name, or if I<type> does not name a
valid type is I<class>.

=item silk.site.B<flowtype_from_id(>I<id>B<)>

Return the flowtype name associated with the numeric ID I<id>.
Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no
arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns B<false>.  Raise an error if no site file is available or
if I<id> is not a valid identifier.

=item silk.site.B<flowtype_id(>I<flowtype>B<)>

Return the numeric flowtype ID associated with the flowtype
I<flowtype> (a string).  Implicitly
calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns
B<false>. Raise an error if no site file is available or if
I<flowtype> is not a valid flowtype name.

=item silk.site.B<flowtypes(>I<>B<)>

Return a sequence containing valid flowtype names.  Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns
B<false>.  Return an empty sequence if no site file is available.

=item silk.site.B<have_site_config(>I<>B<)>

Return B<true> if
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
has been called and was able to successfully find and load a SiLK
configuration file.  Return B<false> otherwise.

=item silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>

Initialize the SiLK system's site configuration.  The I<siteconf>
parameter, if given and non-nil, should be the path and name of a
SiLK site configuration file (see B<silk.conf(3)>).  If I<siteconf>
is omitted or nil, the value specified in the environment variable
SILK_CONFIG_FILE will be used as the name of the configuration
file.  If SILK_CONFIG_FILE is not set, the module looks for a file
named F<silk.conf> in the following directories: the directory
specified by the I<rootdir> argument, the directory specified in
the SILK_DATA_ROOTDIR environment variable; the data root directory
that is compiled into SiLK (@SILK_DATA_ROOTDIR@); the directories
F<$SILK_PATH/share/silk/> and F<$SILK_PATH/share/>.

The I<rootdir> parameter, if given and non-nil, should be the path
to a SiLK data repository that a configuration that matches the
SiLK site configuration.  If I<rootdir> is omitted or nil, the
value specified in the SILK_DATA_ROOTDIR environment variable will
be used, or if that variable is not set, the data root directory
that is compiled into SiLK (@SILK_DATA_ROOTDIR@).  The I<rootdir>
may be specified without a I<siteconf> argument by using nil for
the I<siteconf> argument.  I.e., B<init_site(nil, "/data")>.

If I<verbose> is true, this function will report failures to open
the file as errors.  If verbose is nil, false, or not set, only
parsing failures will be reported.  (For example, if you intend to
try opening several files in a row to find the correct file,
verbose should be nil to avoid several reports of open failures.)

This function should not generally be called explicitly unless one
wishes to use a non-default site configuration file.

The B<init_site()> function can only be called successfully once.
The return value of B<init_site()> will be true if the site
configuration was successful, or B<false> if a site configuration
file was not found.  If a I<siteconf> parameter was specified but
not found, or if a site configuration file was found but did not
parse properly, an exception will be raised instead.  Once
I<init_site()> has been successfully invoked,
silk.site.B<have_site_config()> will return B<true>, and subsequent
invocations of B<init_site()> will raise an error.

=item silk.site.B<sensor_classes(>I<sensor>B<)>

Return a sequence containing class names that are associated with
sensor I<sensor> (a string).
Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no
arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns B<false>.  Raise an error if no site file is available or
if I<sensor> is not a valid sensor name.

=item silk.site.B<sensor_description(>I<sensor>B<)>

Return the description of sensor I<sensor> (a string) as a string,
or B<nil> if there is no description.  Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns
B<false>.  Raise an error if no site file is available or if
I<sensor> is not a valid sensor name.

=item silk.site.B<sensor_from_id(>I<id>B<)>

Return the sensor name associated with the numeric sensor ID I<id>.
Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
no
arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns B<false>.  Raise an error if no site file is available or
if I<id> is not a valid sensor identifier.

=item silk.site.B<sensor_id(>I<sensor>B<)>

Return the numeric sensor ID associated with the sensor I<sensor>
(a string).
Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no
arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns B<false>.  Raise an error if no site file is available or
if I<sensor> is not a valid sensor name.

=item silk.site.B<sensors(>I<>B<)>

Return a sequence containing valid sensor names.  Implicitly calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns
B<false>.  Return an empty sequence if no site file is available.

=item silk.site.B<types(>I<class>B<)>

Return a sequence containing valid type names for class I<class> (a
string).  Implicitly
calls
L<silk.site.B<init_site()>|/"silk.site.B<init_site(>[I<siteconf>B<,> I<rootdir>[, I<verbose>]]B<)>">
with no arguments if
L<silk.site.B<have_site_config()>|/"silk.site.B<have_site_config(>I<>B<)>">
returns
B<false>.  Raise an error if no site file is available or if
I<class> is not a valid class name.

=back

=head2 Stream

A B<stream> object represents a SiLK input or output stream containing
IPFIX or SiLK records.

The following functions create a stream object:

=over 4

=item silk.B<stream_open_reader(>I<filename>, I<type>B<)>

Create a stream that reads records from the file named I<filename>.
Specify I<filename> as C<-> or C<stdin> to read from the standard
input.

The I<type> argument must
be a string designating the expected type of records in
I<filename>, either C<ipfix> for IPFIX files or C<silk> for SiLK
flow files.  The function raises an error if the actual type does
not match the expected type.  The function also raises an error if
it encounters end-of-file or another read error while trying to
determine the type of records in I<filename>.

=item silk.B<stream_open_writer(>I<filename>, I<type>B<)>

Create a stream object that writes records to I<filename>.  Specify
I<filename> as C<-> or C<stdout> to write to the standard output.

The I<type> argument must be a string designating how to represent
records in I<filename>, either C<ipfix> for IPFIX records or
C<silk> for SiLK flow records.

Use B<stream_write()> to write records to I<stream>.
B<stream_write()> accepts either IPFIX or SiLK Flow records; if
necessary, the record is converted to the type specified by
I<type> prior to being written to the stream.

=back

The following functions are defined for stream objects:

=over 4

=item silk.B<stream_close(>I<stream>B<)>

Flush and close I<stream>.

=item silk.B<stream_get_name(>I<stream>B<)>

Return the filename for I<stream>.  Return C<-> if I<stream> is
reading from the standard input or writing to the standard output.

=item silk.B<stream_get_sidecar(>I<stream>B<)>

Return the sidecar description object that exists on the SiLK Flow
record stream I<stream>.  Return B<nil> if no sidecar description
exists.  Raise an error if I<stream> is an IPFIX stream.

=item silk.B<stream_iter(>I<stream>[, I<arg>]B<)>

Return an iterator over the records in I<stream>.  I<stream> must
be open for reading.  Using the iterator consumes the stream.

On each iteration, a single record is read from I<stream> and two
values are returned.  The first returned value is the record or
B<nil> when I<stream> contains no more records.  The second
returned value depends on the type of records in I<stream>: it is
the export time (as a L<datetime|/Datetime>) of the record when
reading from an IPFIX stream or B<nil> when reading from a SiLK
Flow stream.

When I<arg> is not specified, a new record is created and returned
on each iteration.  The type of the record is an L<rwrec|/RWRec>
when I<stream> is reading from a SiLK Flow stream or a
L<fixrec|/Fixrec> when I<stream> is reading from an IPFIX stream.

The type of record to be returned may be specified by giving the
string C<silk> or C<ipfix> as the second argument.  A new record is
created and returned on each iteration.

If the second argument is an rwrec, that record is cleared and
filled on each iteration.  When reading from an IPFIX stream, the
IPFIX record is converted to an rwrec.

If the second argument is a L<fixrec|/Fixrec>, the function clears
that fixrec, fills it with the new data (ignoring I<fixrec>'s
previous L<schema|/Schema>), and returns it on each iteration.
When reading from a SiLK Flow stream, the SiLK record is converted
to IPFIX.

=item silk.B<stream_new_schema_callback(>I<stream>, I<schema_cb>B<)>

Add to I<stream> a callback function I<schema_cb> that is invoked
each time I<stream> sees a new schema.  I<stream> must be an open
for reading IPFIX data.  The I<schema_cb> function is called with
two parameters, the I<stream> and a Schema object representing the
new schema.  The return value of I<schema_cb> is ignored.

=item silk.B<stream_read(>I<stream>[, I<arg>]B<)>

Read a single record from I<stream>.  The optional second argument
and the return values are the same as those described for a single
iteration of the stream iterator.  See
L<stream_iter()|/"silk.B<stream_iter(>I<stream>[, I<arg>]B<)>">.

=item silk.B<stream_set_sidecar(>I<stream>, I<sidecar>B<)>

Set the sidecar description object on the SiLK Flow record stream
I<stream> to I<sidecar>.  Raise an error if I<stream> is not open
for writing, if I<stream> is an IPFIX stream, or if I<sidecar> is
not frozen.

=item silk.B<stream_to_string(>I<stream>B<)>

Return a unique string designating I<stream>.

=item silk.B<stream_write(>I<stream>, I<fixrec>[, I<schema>]B<)>

Write the L<fixrec|/Fixrec> I<fixrec> to I<stream>.  I<stream> must
be open for writing.  If I<schema> is supplied, the fixrec is
written using that L<schema|/Schema> object.  If the type C<silk>
was specified when I<stream> was opened, a SiLK Flow record
approximation of I<fixrec> is written to I<stream>.

=item silk.B<stream_write(>I<stream>, I<rwrec>B<)>

Write the RWRec I<rwrec> to I<stream>.  I<stream> must be open for
writing.  If the type C<ipfix> was specified when I<stream> was
opened, an IPFIX record approximation of I<rwrec> is written to
I<stream>.

=back

=head2 TCP Flags

B<silklua> uses the number type in Lua to hold TCP Flags values, and
there is not a dedicated object type to store TCP Flags values.

=over 4

=item silk.B<tcpflags_matches(>I<integer>, I<string>B<)>

Treat I<integer> as a TCP flags value, such as that produced by
B<tcpflags_parse()>.

Parse I<string> as a pair of TCP flags values separated by a slash
(C</>), where the values before and after the slash are parsed
using B<tcpflags_parse()>.

Treat the TCP flags value that appear after the slash as a mask,
and use it to mask the TCP flags in I<integer>.

Treat the TCP flags value that appear before the slash as a check,
and verify that the masked TCP flag value matches it.  If the
values match, return B<true>; otherwise, return B<false>.

When no slash is present in I<string>, parse it using
B<tcpflags_parse()> and treat it as both the mask and the bits to
check.

=item silk.B<tcpflags_parse(>I<string>B<)>

Parse I<string> as a set of TCP flags and return an unsigned
integer representing those flags.  Any whitespace in I<string> is
ignored.  I<string> may contain the following characters, which map
to the specified value.

=over 4

=item F

=item f

TCP_FIN

=item S

=item s

TCP_SYN

=item R

=item r

TCP_RST

=item P

=item p

TCP_PSH

=item A

=item a

TCP_ACK

=item U

=item u

TCP_URG

=item E

=item e

TCP_ECE

=item C

=item c

TCP_CWR

=back

=item silk.B<tcpflags_to_string(>I<integer>[, I<format>]B<)>

Assume I<integer> represents a TCP flags value and return a
human-readable version of those flags.

Possible values for I<format> are:

=over 4

=item padded

Format the TCP flags with a space representing any unset flag.

=item compact

Format the TCP flags in as few characters as possible.  When
I<integer> is 0, the empty string is returned.

=back

When no I<format> value is specified, the default is I<compact>.

=back

=head1 VARIABLES

=over 4

=item silk.metatables

A table whose keys are the names of the Lua SiLK data types, and whose
values are those types' metatables.

=back

=head1 OPTIONS

The following options are described in the B<lua> manual page and
their documentation is included here for completeness.

=over 4

=item B<-e> I<stat>

Execute statement I<stat>.

=item B<-i>

Enter interactive mode after executing the I<SCRIPT> given on the command
line.

=item B<-l> I<name>

Execute the equivalent of I<name>=B<require('>I<name>B<')> before
executing I<SCRIPT>.

=item B<-v>

Show version information.

=item B<-E>

Ignore environment variables.

=item B<-->

Stop handling options.

=item B<->

Stop handling options and execute the standard input as a file.

=back

=head1 SEE ALSO

L<http://www.lua.org/docs.html>,
L<http://tools.ietf.org/html/rfc7011>,
L<http://tools.ietf.org/html/rfc7012>,
L<http://tools.ietf.org/html/rfc7013>,
L<http://tools.ietf.org/html/rfc6313>,
L<http://tools.ietf.org/html/rfc5610>

=cut

$SiLK: silklua.pod b6bece4ab21f 2016-12-02 17:01:44Z mthomas $

Local Variables:
mode:text
indent-tabs-mode:nil
End:
