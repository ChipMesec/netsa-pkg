/*
** Copyright (C) 2001-2017 by Carnegie Mellon University.
**
** @OPENSOURCE_LICENSE_START@
** See license information in ../../LICENSE.txt
** @OPENSOURCE_LICENSE_END@
*/

/*
 *  rwset.c
 *
 *    Michael Collins
 *    May 6th
 *
 *    rwset is an application which takes filter data and generates a
 *    tree (rwset) of ip addresses which come out of a filter file.
 *    This tree can then be used to generate aggregate properties;
 *    rwsets will be used for filtering large sets of ip addresses,
 *    aggregate properties per element can be counted, &c.
 *
 *
 *
 *    FIXME: This code will do the "wrong" thing with the IPFIX file
 *    gerenated by rwsilk2ipfix (and with the MPLS-containing template
 *    that yaf exports).  Those templates contain both IPv4 and IPv6
 *    addresses for source and destination.  If the user builds an
 *    IPset for "sourceIPv4Address,sourceIPv6Address", that IPset file
 *    is going to contain IP 0.0.0.0.
 *
 *    FIXME: When building an IPset that contains "sourceIPv4Address"
 *    directly from IPFIX generated by yaf, you will get different
 *    results depending on whether you run yaf with the --uniflow
 *    switch since the code does not pay attention to biflow status.
 */

#include <silk/silk.h>

RCSIDENT("$SiLK: rwset.c efd886457770 2017-06-21 18:43:23Z mthomas $");

#include <silk/rwrec.h>
#include <silk/skflowiter.h>
#include <silk/skipaddr.h>
#include <silk/skipset.h>
#include <silk/sksite.h>
#include <silk/skstream.h>
#include <silk/skstringmap.h>
#include <silk/skvector.h>
#include <silk/utils.h>


/* LOCAL DEFINES AND TYPEDEFS */

/* where to write output from --help */
#define USAGE_FH stdout

/* character in --fields-file that separates the list of files from
 * the file name */
#define FIELDS_FILE_SEP     ':'

/* What to do when malloc() fails */
#define EXIT_NO_MEMORY                                               \
    do {                                                             \
        skAppPrintOutOfMemory(NULL);                                 \
        exit(EXIT_FAILURE);                                          \
    } while(0)

/* the sets_t structure maintains the IPsets, the stream where it will
 * be written, and information on the type of IPs to add to the
 * IPset. */
struct sets_st {
    skipset_t          *ipset;
    skstream_t         *stream;
    int                 set_type;
#if 0
    /* following fields are used when set_type is OPT_FIELDS_FILE */
    size_t              num_fields;
    sk_field_ident_t   *fields;
#endif  /* 0 */
};
typedef struct sets_st sets_t;


/* LOCAL VARIABLES */

/* the sets to create; this is an array whose length is given by
 * 'num_sets' */
static sets_t *sets;

/* number of sets to write; the length of the 'sets; array */
static size_t num_sets = 0;

/* a vector of sets_t, used while parsing the command line; once
 * command line is parsed, the vector is used to create the 'sets'
 * array. */
static sk_vector_t *option_vec = NULL;

/* string map of information elements used to parse --fields-file */
static sk_stringmap_t *stringmap = NULL;

/* whether the stdout has been claimed as an output stream */
static unsigned int stdout_used = 0;

/* for input processing */
static sk_options_ctx_t *optctx = NULL;
static sk_flow_iter_t *flowiter = NULL;

/* options for write the IPsets */
static skipset_options_t set_options;


/* OPTIONS SETUP */

typedef enum {
    /* OPT_HELP_FIELDS, */
    /* OPT_FIELDS_FILE, */
    OPT_SIP_FILE,
    OPT_DIP_FILE,
    OPT_NHIP_FILE,
    OPT_ANY_FILE
} appOptionsEnum;

static struct option appOptions[] = {
    /* {"help-fields",         NO_ARG,       0, OPT_HELP_FIELDS}, */
    /* {"fields-file",         REQUIRED_ARG, 0, OPT_FIELDS_FILE}, */
    {"sip-file",            REQUIRED_ARG, 0, OPT_SIP_FILE},
    {"dip-file",            REQUIRED_ARG, 0, OPT_DIP_FILE},
    {"nhip-file",           REQUIRED_ARG, 0, OPT_NHIP_FILE},
    {"any-file",            REQUIRED_ARG, 0, OPT_ANY_FILE},
    {0,0,0,0}               /* sentinel entry */
};

static const char *appHelp[] = {
    /* "Describe each field and exit. Def. no", */
    /* NULL,                       /\* generate dynamically *\/ */
    ("Read SiLK Flow files and create an IPset containing the\n"
     "\tunique source addresses and write it to the named file. Def. No"),
    ("Read SiLK Flow files and create an IPset containing the\n"
     "\tunique destination addresses and write it to the named file. Def. No"),
    ("Read SiLK Flow files and create an IPset containing the\n"
     "\tunique next-hop addresses and write it to the named file. Def. No"),
    ("Read SiLK Flow files and create an IPset containing the\n"
     "\tunique source AND destination addresses and write it to the\n"
     "\tnamed file. Def. No"),
    (char *)NULL
};



/* LOCAL FUNCTION PROTOTYPES */

static int  appOptionsHandler(clientData cData, int opt_index, char *opt_arg);
#if 0
static sk_stringmap_t *create_field_stringmap(const fbInfoModel_t *model);
static void print_help_fields(void);
static int parse_fields_file(const char *fields_file);
#endif  /* 0 */
static void
copy_file_header_callback(
    sk_flow_iter_t     *f_iter,
    skstream_t         *stream,
    void               *data);


/* FUNCTION DEFINITIONS */

/*
 *  appUsageLong();
 *
 *    Print complete usage information to USAGE_FH.  Pass this
 *    function to skOptionsSetUsageCallback(); skOptionsParse() will
 *    call this funciton and then exit the program when the --help
 *    option is given.
 */
static void
appUsageLong(
    void)
{
#define USAGE_MSG                                                            \
    ("<IPSET-CREATION-SWITCHES> [SWITCHES] [FILES]\n"                        \
     "\tRead Flow records and generate one or more binary IPset file(s).\n"  \
     "\tAt least one creation switch must be specified. To write an IPset\n" \
     "\tto the standard output, specify its name as '-' or 'stdout'. When\n" \
     "\tno file names are specified on command line, rwset attempts to\n"    \
     "\tread flows from the standard input.\n")

#define USAGE_FIELDS_FILE                                                    \
    ("Read IPFIX files and create an IPset containing the\n"                 \
     "\tunique IP addresses in the specified information element(s). The\n"  \
     "\targument must contain one or more elements separated by commas,\n"   \
     "\ta '%c', and the destination stream. Repeat the switch to create\n"   \
     "\tmultiple files. Def. None\n")

    FILE *fh = USAGE_FH;
    unsigned int i;

    fprintf(fh, "%s %s", skAppName(), USAGE_MSG);
    fprintf(fh, "\nSWITCHES:\n");
    skOptionsDefaultUsage(fh);
    for (i = 0; appOptions[i].name; ++i) {
        switch (appOptions[i].val) {
#if 0
          case OPT_FIELDS_FILE:
            fprintf(fh, "--%s %s. ",
                    appOptions[i].name, SK_OPTION_HAS_ARG(appOptions[i]));
            fprintf(fh, USAGE_FIELDS_FILE, FIELDS_FILE_SEP);
            break;
#endif  /* 0 */
          default:
            fprintf(fh, "--%s %s. %s\n", appOptions[i].name,
                    SK_OPTION_HAS_ARG(appOptions[i]), appHelp[i]);
            break;
        }
    }

    skIPSetOptionsUsage(fh);
    skOptionsCtxOptionsUsage(optctx, fh);
    sksiteOptionsUsage(fh);
}


/*
 *  appTeardown()
 *
 *    Teardown all modules, close all files, and tidy up all
 *    application state.
 *
 *    This function is idempotent.
 */
static void
appTeardown(
    void)
{
    static int teardownFlag = 0;
    sets_t vec_s;
    sets_t *s;
    size_t i;

    if (teardownFlag) {
        return;
    }
    teardownFlag = 1;

    for (i = 0, s = sets; i < num_sets; ++i, ++s) {
        skIPSetDestroy(&s->ipset);
        skStreamDestroy(&s->stream);
    }
    free(sets);

    /* close the copy stream */
    skOptionsCtxCopyStreamClose(optctx, &skAppPrintErr);

    if (option_vec) {
        s = &vec_s;
        for (i = 0; i < sk_vector_get_count(option_vec); ++i) {
            sk_vector_get_value(option_vec, i, s);
            skIPSetDestroy(&s->ipset);
            skStreamDestroy(&s->stream);
        }
        sk_vector_destroy(option_vec);
    }

    skIPSetOptionsTeardown();
    sk_flow_iter_destroy(&flowiter);
    skStringMapDestroy(stringmap);
    skOptionsCtxDestroy(&optctx);
    skAppUnregister();
}


/*
 *  appSetup(argc, argv);
 *
 *    Perform all the setup for this application include setting up
 *    required modules, parsing options, etc.  This function should be
 *    passed the same arguments that were passed into main().
 *
 *    Returns to the caller if all setup succeeds.  If anything fails,
 *    this function will cause the application to exit with a FAILURE
 *    exit status.
 */
static void
appSetup(
    int                 argc,
    char              **argv)
{
    SILK_FEATURES_DEFINE_STRUCT(features);
    unsigned int optctx_flags;
    size_t i;
    size_t j;
    int rv;

    /* verify same number of options and help strings */
    assert((sizeof(appHelp)/sizeof(char *)) ==
           (sizeof(appOptions)/sizeof(struct option)));

    /* register the application */
    skAppRegister(argv[0]);
    skAppVerifyFeatures(&features, NULL);
    skOptionsSetUsageCallback(&appUsageLong);

    /* initialize globals */
    memset(&set_options, 0, sizeof(skipset_options_t));
    set_options.existing_silk_files = 1;
    set_options.argc = argc;
    set_options.argv = argv;

    optctx_flags = (SK_OPTIONS_CTX_INPUT_SILK_FLOW | SK_OPTIONS_CTX_ALLOW_STDIN
                    | SK_OPTIONS_CTX_XARGS | SK_OPTIONS_CTX_PRINT_FILENAMES
                    | SK_OPTIONS_CTX_COPY_INPUT | SK_OPTIONS_CTX_IPV6_POLICY);

    /* register the options */
    if (skOptionsCtxCreate(&optctx, optctx_flags)
        || skOptionsCtxOptionsRegister(optctx)
        || skOptionsRegister(appOptions, &appOptionsHandler, NULL)
        || skIPSetOptionsRegister(&set_options)
        || sksiteOptionsRegister(SK_SITE_FLAG_CONFIG_FILE))
    {
        skAppPrintErr("Unable to register options");
        exit(EXIT_FAILURE);
    }

    /* register the teardown handler */
    if (atexit(appTeardown) < 0) {
        skAppPrintErr("Unable to register appTeardown() with atexit()");
        appTeardown();
        exit(EXIT_FAILURE);
    }

#if 0
    /* create the string map of fields */
    stringmap = create_field_stringmap(info_model);
    if (NULL == stringmap) {
        skAppPrintErr("Unable to create string map");
        exit(EXIT_FAILURE);
    }
#endif  /* 0 */

    /* create a vector used while parsing the command line */
    option_vec = sk_vector_create(sizeof(sets_t));

    /* Parse options */
    rv = skOptionsCtxOptionsParse(optctx, argc, argv);
    if (rv < 0) {
        skAppUsage();           /* never returns */
    }

    /* try to load site config file; if it fails, we will not be able
     * to resolve flowtype and sensor from input file names */
    sksiteConfigure(0);

    /* Make certain the user has requested some output. */
    num_sets = sk_vector_get_count(option_vec);
    if (0 == num_sets) {
        skAppPrintErr("No output specified; must specify file(s) to create");
        skAppUsage();
    }

    /* convert the vector to a local array */
    sets = (sets_t*)sk_vector_to_array_alloc(option_vec);
    sk_vector_destroy(option_vec);
    option_vec = NULL;

    /* make certain stdout is not being used for multiple outputs */
    if (stdout_used && skOptionsCtxCopyStreamIsStdout(optctx)) {
        skAppPrintErr("May not use stdout for multiple output streams");
        exit(EXIT_FAILURE);
    }

    /* create flow iterator to read the records from the stream */
    flowiter = skOptionsCtxCreateFlowIterator(optctx);
    sk_flow_iter_set_stream_event_cb(
        flowiter, SK_FLOW_ITER_CB_EVENT_PRE_READ,
        &copy_file_header_callback, NULL);

    /* Open each output file; if any open fails, remove any files we
     * have previously opened. */
    for (i = 0; i < num_sets; ++i) {
        rv = skStreamOpen(sets[i].stream);
        if (rv) {
            skStreamPrintLastErr(sets[i].stream, rv, &skAppPrintErr);
            for (j = 0; j < i; ++j) {
                if (skStreamIsSeekable(sets[j].stream)) {
                    unlink(skStreamGetPathname(sets[j].stream));
                }
            }
            exit(EXIT_FAILURE);
        }
    }

    /* open the --copy-input stream */
    if (skOptionsCtxOpenStreams(optctx, &skAppPrintErr)) {
        exit(EXIT_FAILURE);
    }

    return;                       /* OK */
}


/*
 *  status = appOptionsHandler(cData, opt_index, opt_arg);
 *
 *    This function is passed to skOptionsRegister(); it will be called
 *    by skOptionsParse() for each user-specified switch that the
 *    application has registered; it should handle the switch as
 *    required---typically by setting global variables---and return 1
 *    if the switch processing failed or 0 if it succeeded.  Returning
 *    a non-zero from from the handler causes skOptionsParse() to return
 *    a negative value.
 *
 *    The clientData in 'cData' is typically ignored; 'opt_index' is
 *    the index number that was specified as the last value for each
 *    struct option in appOptions[]; 'opt_arg' is the user's argument
 *    to the switch for options that have a REQUIRED_ARG or an
 *    OPTIONAL_ARG.
 */
static int
appOptionsHandler(
    clientData   UNUSED(cData),
    int                 opt_index,
    char               *opt_arg)
{
    const sets_t *s;
    sets_t new_set;
    int rv;
    size_t i;

    switch ((appOptionsEnum)opt_index) {
#if 0
      case OPT_HELP_FIELDS:
        print_help_fields();
        exit(EXIT_SUCCESS);
#endif

      case OPT_SIP_FILE:
      case OPT_DIP_FILE:
      case OPT_NHIP_FILE:
      case OPT_ANY_FILE:
        /* check for duplicates */
        for (i = 0;
             (s = (sets_t*)sk_vector_get_value_pointer(option_vec, i)) != NULL;
             ++i)
        {
            if (s->set_type == opt_index) {
                skAppPrintErr("Invalid %s: Switch used multiple times",
                              appOptions[opt_index].name);
                return 1;
            }
        }
        /* check for multiple streams using stdout */
        if (0 == strcmp(opt_arg, "stdout") || 0 == strcmp(opt_arg, "-")) {
            if (stdout_used) {
                skAppPrintErr("Multiple outputs are trying to use stdout");
                return 1;
            }
            stdout_used = 1;
        }
        /* create the output stream */
        memset(&new_set, 0, sizeof(new_set));
        new_set.set_type = opt_index;
        if ((rv = skStreamCreate(
                 &(new_set.stream), SK_IO_WRITE, SK_CONTENT_SILK))
            || (rv = skStreamBind(new_set.stream, opt_arg)))
        {
            skStreamPrintLastErr(new_set.stream, rv, &skAppPrintErr);
            skStreamDestroy(&(new_set.stream));
            return 1;
        }
        /* create the IPset */
        if (skIPSetCreate(&(new_set.ipset), 0)) {
            EXIT_NO_MEMORY;
        }
        skIPSetOptionsBind(new_set.ipset, &set_options);
        sk_vector_append_value(option_vec, &new_set);
        break;
#if 0
      case OPT_FIELDS_FILE:
        /* cannot mix with silk-3 style switches */
        if (is_silk) {
            s = (sets_t*)sk_vector_get_value_pointer(option_vec, 0);
            skAppPrintErr("Invalid %s: May not be mixed with usage of %s",
                          appOptions[opt_index].name,
                          appOptions[s->set_type].name);
            return 1;
        }
        ++is_ipfix;
        if (parse_fields_file(opt_arg)) {
            return 1;
        }
        break;
#endif  /* 0 */
    }

    return 0;                     /* OK */
}


#if 0
/*
 *    Create and return the stringmap used to parse the field name in
 *    the --fields-file switch.
 *
 *    This function visits each element in the information model and
 *    adds it to the string map if the element's type is an IPaddress.
 */
static sk_stringmap_t *
create_field_stringmap(
    const fbInfoModel_t    *model)
{
    char buf[32];
    sk_stringmap_t *map = NULL;
    fbInfoModelIter_t iter;
    const fbInfoElement_t *ie;
    sk_stringmap_id_t id;
    sk_stringmap_status_t err;
    sk_stringmap_entry_t entry;

    if ((err = skStringMapCreate(&map))) {
        goto ERROR;
    }

    id = 0;
    fbInfoModelIterInit(&iter, model);
    while ((ie = fbInfoModelIterNext(&iter)) != NULL) {
        if (ie->type == FB_IP4_ADDR || ie->type == FB_IP6_ADDR) {
            entry.id = id++;
            entry.name = ie->ref.name;
            entry.description = ie->description;
            entry.userdata = ie;
            if ((err = skStringMapAddEntries(map, 1, &entry))) {
                goto ERROR;
            }
            /* create the "ieXXX" alias */
            if (ie->ent) {
                snprintf(buf, sizeof(buf), "ie%" PRIu32 "/%" PRIu16,
                         ie->ent, ie->num);
            } else {
                snprintf(buf, sizeof(buf), "ie%" PRIu16, ie->num);
            }
            entry.name = buf;
            if ((err = skStringMapAddEntries(map, 1, &entry))) {
                goto ERROR;
            }
        }
    }

    return map;

  ERROR:
    skAppPrintErr("Could not create field string map: %s",
                  skStringMapStrerror(err));
    skStringMapDestroy(map);
    return NULL;
}


/*
 *    Print help text describing the fields allowed in the
 *    --fields-file switch.
 */
static void
print_help_fields(
    void)
{
    FILE *fh = USAGE_FH;

    fprintf(fh, ("%s: The following field may be used in the --%s switch.\n"
                 "Names are case-insenstive and may be abbreviated"
                 " to the shortest unique prefix.\n"),
            skAppName(), appOptions[OPT_FIELDS_FILE].name);
    skStringMapPrintDetailedUsage(stringmap, fh);
}


/*
 *    Parse the argument to the --fields-file switch and add a new
 *    entry onto the option_vec vector.
 */
static int
parse_fields_file(
    const char         *fields_file)
{
    sets_t new_set;
    char *sp;
    char *copy = NULL;
    sk_vector_t *vec;
    sk_stringmap_iter_t *sm_iter = NULL;
    sk_stringmap_entry_t *sm_entry;
    char *errmsg;
    const fbInfoElement_t *fb_ie;
    sk_field_ident_t ident;
    ssize_t rv;

    memset(&new_set, 0, sizeof(new_set));
    new_set.set_type = OPT_FIELDS_FILE;

    if (!fields_file || !*fields_file) {
        skAppPrintErr("Invalid %s: Value is empty",
                      appOptions[OPT_FIELDS_FILE].name);
        goto ERROR;
    }

    /* Create a version of the argument to modify */
    copy = strdup(fields_file);
    if (NULL == copy) {
        EXIT_NO_MEMORY;
    }

    /* Set the separator between fields and stream to '\0' and move
     * 'sp' to the start of the stream */
    sp = strchr(copy, FIELDS_FILE_SEP);
    if (NULL == sp) {
        skAppPrintErr(("Invalid %s '%s':"
                       " Expected '%c' between fields and stream"),
                      appOptions[OPT_FIELDS_FILE].name, fields_file,
                      FIELDS_FILE_SEP);
        goto ERROR;
    }
    *sp = '\0';
    ++sp;

    /* check for multiple streams using stdout */
    if (0 == strcmp(sp, "stdout") || 0 == strcmp(sp, "-")) {
        if (stdout_used) {
            skAppPrintErr("Multiple outputs are trying to use stdout");
            goto ERROR;
        }
        stdout_used = 1;
    }

    /* create the stream */
    if ((rv = skStreamCreate(&(new_set.stream), SK_IO_WRITE, SK_CONTENT_SILK))
        || (rv = skStreamBind(new_set.stream, sp)))
    {
        skStreamPrintLastErr(new_set.stream, rv, &skAppPrintErr);
        goto ERROR;
    }
    /* create the IPset */
    if (skIPSetCreate(&(new_set.ipset), 0)) {
        EXIT_NO_MEMORY;
    }
    skIPSetOptionsBind(new_set.ipset, &set_options);

    /* create a vector to use while parsing the fields */
    vec = sk_vector_create(sizeof(sk_field_ident_t));

    /* parse the field-list */
    if (skStringMapParse(
            stringmap, copy, SKSTRINGMAP_DUPES_ERROR, &sm_iter, &errmsg))
    {
        skAppPrintErr("Invalid %s: %s",
                      appOptions[OPT_FIELDS_FILE].name, errmsg);
        goto ERROR;
    }
    while (skStringMapIterNext(sm_iter, &sm_entry, NULL) == SK_ITERATOR_OK) {
        fb_ie = (const fbInfoElement_t*)sm_entry->userdata;
        ident = SK_FIELD_IDENT_CREATE(fb_ie->ent, fb_ie->num);
        sk_vector_append_value(vec, &ident);
    }

    /* convert the vector to an array */
    new_set.num_fields = sk_vector_get_count(vec);
    new_set.fields = (sk_field_ident_t*)sk_vector_to_array_alloc(vec);

    /* add new set to the list of outputs */
    sk_vector_append_value(option_vec, &new_set);

    /* clean up */
    skStringMapIterDestroy(sm_iter);
    sk_vector_destroy(vec);
    free(copy);

    return 0;

  ERROR:
    free(copy);
    skStringMapIterDestroy(sm_iter);
    skStreamDestroy(&new_set.stream);
    skIPSetDestroy(&new_set.ipset);
    return -1;
}


/*
 *    This is used an sk_schema_t to free its context pointer when the
 *    schema is destroyed.  This function is dependent on the
 *    'num_sets' global.
 */
static void
free_vec_array(
    void               *v_vec_arary)
{
    sk_vector_t **vec_array = (sk_vector_t**)v_vec_arary;
    size_t i;

    if (vec_array) {
        for (i = 0; i < num_sets; ++i) {
            sk_vector_destroy(vec_array[i]);
        }
        free(vec_array);
    }
}


/*
 *    Add a context object to an sk_schema_t when the schema is first
 *    noticed by the stream.
 */
static void
new_schema_callback(
    sk_schema_t        *schema,
    uint16_t     UNUSED(tid),
    void        UNUSED(*v_unused))
{
    sk_vector_t **vec_array;
    const sk_field_t *field;
    size_t i;
    size_t j;
    sets_t *s;

    /* create an array of vectors, one vector for each output; each
     * vector holds 'sk_field_t*' that point to the locations of IP
     * fields in the schema that are needed for that particular output
     * IPset/stream. */
    vec_array = sk_alloc_array(sk_vector_t*, num_sets);

    for (i = 0, s = sets; i < num_sets; ++i, ++s) {
        vec_array[i] = sk_vector_create(sizeof(sk_field_t*));
        for (j = 0; j < s->num_fields; ++j) {
            field = sk_schema_get_field_by_ident(schema, s->fields[j], 0);
            if (field) {
                sk_vector_append_value(vec_array[i], &field);
            }
        }
    }

    sk_schema_set_context(schema, ctx_ident, vec_array, free_vec_array);
}


/*
 *  status = process_ipfix_files();
 *
 *    Read the records from all input streams and add them to the
 *    appropriate IPSet files.  Return 0 on success, or non-zero on
 *    failure.
 */
static int
process_ipfix_files(
    void)
{
    const sk_fixrec_t *rec;
    const sk_schema_t *schema;
    const sk_field_t *field;
    sets_t *s;
    skipaddr_t ipaddr;
    ssize_t rv = SKIPSET_OK;
    ssize_t rv_in;
    sk_vector_t **vec_array;
    skcontent_t content;
    size_t i;
    size_t j;

    /* Read in records */
    while ((rv_in = sk_flow_iter_get_next_rec2(flowiter, NULL, &rec, &content))
           == 0)
    {
        schema = sk_fixrec_get_schema(rec);
        vec_array = (sk_vector_t**)sk_schema_get_context(schema, ctx_ident);

        for (i = 0, s = sets; i < num_sets; ++i, ++s) {
            for (j = 0; j < sk_vector_get_count(vec_array[i]); ++j) {
                sk_vector_get_value(vec_array[i], j, &field);
                sk_fixrec_get_ip_address(rec, field, &ipaddr);
                rv = skIPSetInsertAddress(s->ipset, &ipaddr, 0);
                if (rv) {
                    skAppPrintErr("Error adding IP to %s: %s",
                                  skStreamGetPathname(s->stream),
                                  skIPSetStrerror(rv));
                }
            }
        }
    }

    return ((SKSTREAM_ERR_EOF == rv_in) ? 0 : -1);
}
#endif  /* 0 */


/*
 *    Copy the annotation and command line entries from the header of
 *    the input stream 'stream' to the headers of all output streams.
 *
 *    This is a callback function registered with the global
 *    sk_flow_iter_t 'flowiter' and it may be invoked by
 *    sk_flow_iter_get_next_rec().
 */
static void
copy_file_header_callback(
    sk_flow_iter_t  UNUSED(*f_iter),
    skstream_t             *stream,
    void            UNUSED(*data))
{
    size_t i;
    int rv;

    for (i = 0; i < num_sets; ++i) {
        if ((rv = skHeaderCopyEntries(skStreamGetSilkHeader(sets[i].stream),
                                      skStreamGetSilkHeader(stream),
                                      SK_HENTRY_INVOCATION_ID))
            || (rv = skHeaderCopyEntries(skStreamGetSilkHeader(sets[i].stream),
                                         skStreamGetSilkHeader(stream),
                                         SK_HENTRY_ANNOTATION_ID)))
        {
            skStreamPrintLastErr(sets[i].stream, rv, &skAppPrintErr);
        }
    }
}


/*
 *  status = process_silk_files();
 *
 *    Read the records from all input streams and add them to the
 *    appropriate IPSet files.  Return 0 on success, or non-zero on
 *    failure.
 */
static int
process_silk_files(
    void)
{
    rwRec rec;
    skipaddr_t ip;
    ssize_t rv = SKIPSET_OK;
    ssize_t rv_in;
    size_t i = 0;

    rwRecInitialize(&rec, NULL);

    /* Read in records */
    while ((rv_in = sk_flow_iter_get_next_rec(flowiter, &rec)) == 0) {
        for (i = 0; i < num_sets; ++i) {
            switch (sets[i].set_type) {
              case OPT_SIP_FILE:
                rwRecMemGetSIP(&rec, &ip);
                rv = skIPSetInsertAddress(sets[i].ipset, &ip, 0);
                break;
              case OPT_ANY_FILE:
                rwRecMemGetSIP(&rec, &ip);
                rv = skIPSetInsertAddress(sets[i].ipset, &ip, 0);
                if (rv) {
                    break;
                }
                /* FALLTHROUGH */
              case OPT_DIP_FILE:
                rwRecMemGetDIP(&rec, &ip);
                rv = skIPSetInsertAddress(sets[i].ipset, &ip, 0);
                break;
              case OPT_NHIP_FILE:
                rwRecMemGetNhIP(&rec, &ip);
                rv = skIPSetInsertAddress(sets[i].ipset, &ip, 0);
                break;
              default:
                skAbortBadCase(sets[i].set_type);
            }

            if (rv) {
                skAppPrintErr("Error adding IP to %s: %s",
                              appOptions[i].name, skIPSetStrerror(rv));
                return -1;
            }
        }
    }

    return ((SKSTREAM_ERR_EOF == rv_in) ? 0 : -1);
}


int main(int argc, char **argv)
{
    char errbuf[2 * PATH_MAX];
    ssize_t rv = SKIPSET_OK;
    int had_err = 0;
    size_t i;

    appSetup(argc, argv);                 /* never returns on error */

    /* Read in records */
    rv = process_silk_files();
    if (rv) {
        exit(EXIT_FAILURE);
    }

    /* Write the output */
    for (i = 0; i < num_sets; ++i) {
        skIPSetClean(sets[i].ipset);
        rv = skIPSetWrite(sets[i].ipset, sets[i].stream);
        if (SKIPSET_OK == rv) {
            rv = skStreamClose(sets[i].stream);
            if (rv) {
                had_err = 1;
                skStreamLastErrMessage(sets[i].stream, rv,
                                       errbuf, sizeof(errbuf));
                skAppPrintErr("Error writing %s IPset: %s",
                              appOptions[sets[i].set_type].name, errbuf);
            }
        } else if (SKIPSET_ERR_FILEIO == rv) {
            had_err = 1;
            rv = skStreamGetLastReturnValue(sets[i].stream);
            skStreamLastErrMessage(sets[i].stream, rv, errbuf, sizeof(errbuf));
            skAppPrintErr("Error writing %s IPset: %s",
                          appOptions[sets[i].set_type].name, errbuf);
        } else {
            had_err = 1;
            skAppPrintErr("Error writing %s IPset to '%s': %s",
                          appOptions[sets[i].set_type].name,
                          skStreamGetPathname(sets[i].stream),
                          skIPSetStrerror(rv));
        }
        skStreamDestroy(&sets[i].stream);
        skIPSetDestroy(&sets[i].ipset);
        sets[i].ipset = NULL;
    }

    /* done */
    return ((had_err) ? EXIT_FAILURE : EXIT_SUCCESS);
}


/*
** Local Variables:
** mode:c
** indent-tabs-mode:nil
** c-basic-offset:4
** End:
*/
